+func write(writer: file@Writer)
	; Default values.
	do writer.writeStr("function DV_(t){\n")
	do writer.writeStr("switch(t){\n")
	do writer.writeStr("case 0x00:\n")
	do writer.writeStr("case 0x07:\n")
	do writer.writeStr("case 0x09:\n")
	do writer.writeStr("return new Uint32Array(2);\n")
	do writer.writeStr("case 0x01:\n")
	do writer.writeStr("case 0x02:\n")
	do writer.writeStr("case 0x04:\n")
	do writer.writeStr("case 0x05:\n")
	do writer.writeStr("case 0x06:\n")
	do writer.writeStr("return 0;\n")
	do writer.writeStr("case 0x03:\n")
	do writer.writeStr("return false;\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return null;\n")
	do writer.writeStr("}\n")
	
	; Discard types to get the 'value' type of a dictionary.
	do writer.writeStr("function DT_(t){\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return DT_(t.slice(1));\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return DT_(DT_(t.slice(1)));\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return t.slice(1);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'dictRotateLeft'.
	do writer.writeStr("function DRL_(n){\n")
	do writer.writeStr("let r=n.CR;\n")
	do writer.writeStr("n.CR=r.CL;\n")
	do writer.writeStr("r.CL=n;\n")
	do writer.writeStr("r.R=n.R;\n")
	do writer.writeStr("n.R=true;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'dictRotateRight'.
	do writer.writeStr("function DRR_(n){\n")
	do writer.writeStr("let l=n.CL;\n")
	do writer.writeStr("n.CL=l.CR;\n")
	do writer.writeStr("l.CR=n;\n")
	do writer.writeStr("l.R=n.R;\n")
	do writer.writeStr("n.R=true;\n")
	do writer.writeStr("return l;\n")
	do writer.writeStr("}\n")
	
	; 'dictFlip'.
	do writer.writeStr("function DFL_(n){\n")
	do writer.writeStr("n.R=!n.R;\n")
	do writer.writeStr("n.CL.R=!n.CL.R;\n")
	do writer.writeStr("n.CR.R=!n.CR.R;\n")
	do writer.writeStr("}\n")
	
	; 'dictFixUp'.
	do writer.writeStr("function DFU_(n){\n")
	do writer.writeStr("if(n.CR!=null&&n.CR.R)n=DRL_(n);\n")
	do writer.writeStr("if(n.CL!=null&&n.CL.R&&n.CL.CL!=null&&n.CL.CL.R)n=DRR_(n);\n")
	do writer.writeStr("if(n.CL!=null&&n.CL.R&&n.CR!=null&&n.CR.R)DFL_(n);\n")
	do writer.writeStr("return n;\n")
	do writer.writeStr("}\n")
	
	; 'add' to 'dict'.
	do writer.writeStr("function DA_(d,t,k,v){\n")
	if(!\option@rls)
		do writer.writeStr("if(k===null)throw 0xc0000005;\n")
	end if
	do writer.writeStr("let a=false,m=CM_(t[1]);\n")
	do writer.writeStr("d.B=f(d.B);\n")
	do writer.writeStr("d.B.R=false;\n")
	do writer.writeStr("if(a)d.L++;\n")
	do writer.writeStr("function f(n){\n")
	do writer.writeStr("if(n==null){a=true;return{K:k,V:v,CL:null,CR:null,R:true}}\n")
	do writer.writeStr("let c=m(k,n.K);\n")
	do writer.writeStr("if(c==0){n.V=v;return n;}\n")
	do writer.writeStr("if(c<0)n.CL=f(n.CL);else n.CR=f(n.CR);\n")
	do writer.writeStr("return DFU_(n);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'dictMoveRedLeft'.
	do writer.writeStr("function DML_(n){\n")
	do writer.writeStr("DFL_(n);\n")
	do writer.writeStr("if(n.CR.CL!=null&&n.CR.CL.R){\n")
	do writer.writeStr("n.CR=DRR_(n.CR);\n")
	do writer.writeStr("n=DRL_(n);\n")
	do writer.writeStr("DFL_(n);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return n;\n")
	do writer.writeStr("}\n")
	
	; 'dictMoveRedRight'.
	do writer.writeStr("function DMR_(n){\n")
	do writer.writeStr("DFL_(n);\n")
	do writer.writeStr("if(n.CL.CL!=null&&n.CL.CL.R){\n")
	do writer.writeStr("n=DRR_(n);\n")
	do writer.writeStr("DFL_(n);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return n;\n")
	do writer.writeStr("}\n")
	
	; 'dictDelMinRec'.
	do writer.writeStr("function DDM_(n){\n")
	do writer.writeStr("if(n.CL==null)return null;\n")
	do writer.writeStr("if(!n.CL.R&&!(n.CL.CL!=null&&n.CL.CL.R))n=DML_(n);\n")
	do writer.writeStr("n.CL=DDM_(n.CL);\n")
	do writer.writeStr("return DFU_(n);\n")
	do writer.writeStr("}\n")
	
	; 'del' from 'dict'.
	do writer.writeStr("function DD_(e,t,k){\n")
	if(!\option@rls)
		do writer.writeStr("if(k===null)throw 0xc0000005;\n")
	end if
	do writer.writeStr("let d={$:false},m=CM_(t[1]);\n")
	do writer.writeStr("e.B=f(e.B,k,d);\n")
	do writer.writeStr("if(e.B!=null)e.B.R=false;\n")
	do writer.writeStr("if(d.$)e.L--;\n")
	do writer.writeStr("function f(n,k,d){\n")
	do writer.writeStr("if(n==null)return null;\n")
	do writer.writeStr("if(m(k,n.K)<0){\n")
	do writer.writeStr("if(n.CL!=null&&!n.CL.R&&!(n.CL.CL!=null&&n.CL.CL.R))n=DML_(n);\n")
	do writer.writeStr("n.CL=f(n.CL,k,d);\n")
	do writer.writeStr("}else{\n")
	do writer.writeStr("if(n.CL!=null&&n.CL.R)n=DRR_(n);\n")
	do writer.writeStr("if(n.CR!=null&&!n.CR.R&&!(n.CR.CL!=null&&n.CR.CL.R))n=DMR_(n);\n")
	do writer.writeStr("if(m(k,n.K)==0){\n")
	do writer.writeStr("d.$=true;\n")
	do writer.writeStr("if(n.CR==null)return null;\n")
	do writer.writeStr("let p=n.CR;\n")
	do writer.writeStr("while(p.CL!=null)p=p.CL;\n")
	do writer.writeStr("n.K=p.K;\n")
	do writer.writeStr("n.V=p.V;\n")
	do writer.writeStr("n.CR=DDM_(n.CR);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("else\n")
	do writer.writeStr("n.CR=f(n.CR,k,d);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return DFU_(n);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'tobin' implementation.
	do writer.writeStr("function TB_(t,v){\n")
	do writer.writeStr("function l(n){let m=n&0x80000000?0xff:0;return[n&0xff,(n>>>8)&0xff,(n>>>16)&0xff,(n>>>24)&0xff,m,m,m,m];}\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("if(t[1]==\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let w=v.S,r=l(w.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<w.length;i++)r=r.concat(TB_(c,w.charCodeAt(i)));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n") {Fall through.}
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let r=l(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)r=r.concat(TB_(c,v[i]));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let p=v.H,n=-1,i=0;\n")
	do writer.writeStr("while(p!=null){\n")
	do writer.writeStr("if(p==v.P){n=i;break;}")
	do writer.writeStr("p=p.N;i++;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("let r=l(v.L).concat(l(n)),c=t.slice(1);\n")
	do writer.writeStr("p=v.H;while(p!=null){r=r.concat(TB_(c,p.I));p=p.N;}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let r=l(v.L),p=t.slice(1),q=DT_(p);\n")
	do writer.writeStr("f(v.B);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("function f(d){\n")
	do writer.writeStr("if(d.CL!=null)f(d.CL);\n")
	do writer.writeStr("r=r.concat(TB_(p,d.K),TB_(q,d.V));\n")
	do writer.writeStr("if(d.CR!=null)f(d.CR);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("return l(v.Y_).concat(CT_[v.Y_+\{%toBin $ \convert@MethodOffset $ int}](v));\n")
	do writer.writeStr("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n0=v[0],n1=v[1];\n")
	do writer.writeStr("return [n1&0xff,(n1>>>8)&0xff,(n1>>>16)&0xff,(n1>>>24)&0xff,n0&0xff,(n0>>>8)&0xff,(n0>>>16)&0xff,(n0>>>24)&0xff];\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%bool_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return [v&0xff];\n")
	do writer.writeStr("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return [v&0xff,(v>>>8)&0xff];\n")
	do writer.writeStr("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return [v&0xff,(v>>>8)&0xff,(v>>>16)&0xff,(v>>>24)&0xff];\n")
	do writer.writeStr("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let b=new ArrayBuffer(8),f=new Float64Array(b),i=new Uint32Array(b);\n")
	do writer.writeStr("f[0]=v;\n")
	do writer.writeStr("let n0=i[0],n1=i[1];\n")
	do writer.writeStr("return [n0&0xff,(n0>>>8)&0xff,(n0>>>16)&0xff,(n0>>>24)&0xff,n1&0xff,(n1>>>8)&0xff,(n1>>>16)&0xff,(n1>>>24)&0xff];\n")
	do writer.writeStr("}\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return l(-1);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'frombin' implementation.
	do writer.writeStr("function FB_(t,b,o){\n")
	do writer.writeStr("function l(b,o){let r=b[o.$[1]]|(b[o.$[1]+1]<<8)|(b[o.$[1]+2]<<16)|(b[o.$[1]+3]<<24);o.$[1]+=8;return r;}\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("if(t[1]==\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
	do writer.writeStr("let r=\"\",c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++)r+=String.fromCharCode(FB_(c,b,o));\n")
	do writer.writeStr("return{S:r};\n")
	do writer.writeStr("}else{\n")
	do writer.writeStr("let r=new Array(n),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++)r[i]=FB_(c,b,o);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);\n")
	do writer.writeStr("if(n==-1)return null;\n")
	do writer.writeStr("let p=l(b,o),r={L:n,H:null,T:null,P:null},c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++){\n")
	do writer.writeStr("let m={P:null,N:null,I:FB_(c,b,o)};\n")
	do writer.writeStr("if(r.H==null){r.H=m;r.T=m;}else{m.P=r.T;r.T.N=m;r.T=m;}\n")
	do writer.writeStr("if(i==p)r.P=m;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("let r=[],c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++)r.push(FB_(c,b,o));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("let r={L:0,B:null},p=t.slice(1),q=DT_(p);\n")
	do writer.writeStr("for(let i=0;i<n;i++)\n")
	do writer.writeStr("DA_(r,t,FB_(p,b,o),FB_(q,b,o));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let y=l(b,o);if(y==-1)return null;\n")
	do writer.writeStr("return CT_[y+\{%fromBin $ \convert@MethodOffset $ int}](null,b,o);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let r=Uint32Array.from([b[o.$[1]+4]|(b[o.$[1]+5]<<8)|(b[o.$[1]+6]<<16)|(b[o.$[1]+7]<<24),b[o.$[1]]|(b[o.$[1]+1]<<8)|(b[o.$[1]+2]<<16)|(b[o.$[1]+3]<<24)]);\n")
	do writer.writeStr("o.$[1]+=8;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%bool_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let r=b[o.$[1]];\n")
	do writer.writeStr("o.$[1]++;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let r=b[o.$[1]]|(b[o.$[1]+1]<<8);\n")
	do writer.writeStr("o.$[1]+=2;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let r=b[o.$[1]]|(b[o.$[1]+1]<<8)|(b[o.$[1]+2]<<16)|(b[o.$[1]+3]<<24);\n")
	do writer.writeStr("o.$[1]+=4;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let c=new ArrayBuffer(8),f=new Float64Array(c),i=new Uint32Array(c);\n")
	do writer.writeStr("i[0]=b[o.$[1]]|(b[o.$[1]+1]<<8)|(b[o.$[1]+2]<<16)|(b[o.$[1]+3]<<24);\n")
	do writer.writeStr("i[1]=b[o.$[1]+4]|(b[o.$[1]+5]<<8)|(b[o.$[1]+6]<<16)|(b[o.$[1]+7]<<24);\n")
	do writer.writeStr("o.$[1]+=8;\n")
	do writer.writeStr("return f[0];\n")
	do writer.writeStr("}\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return null;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'copy' implementation.
	do writer.writeStr("function C_(t,v){\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(t[1]==\{%char_ $ \convert@RuntimeTypeId $ int})\n")
	do writer.writeStr("return v==null?null:{S:v.S};\n")
	do writer.writeStr("else{\n")
	do writer.writeStr("let a=new Array(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)a[i]=C_(c,v[i]);\n")
	do writer.writeStr("return a;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let l={L:v.L,H:null,T:null,P:null},p=v.H,c=t.slice(1);\n")
	do writer.writeStr("while(p!=null){\n")
	do writer.writeStr("let n={P:null,N:null,I:C_(c,p.I)};\n")
	do writer.writeStr("if(l.H==null){l.H=n;l.T=n;}else{n.P=l.T;l.T.N=n;l.T=n;}\n")
	do writer.writeStr("if(p==v.P)l.P=n;\n")
	do writer.writeStr("p=p.N;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return l;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let s=new Array(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)s[i]=C_(c,v[i]);\n")
	do writer.writeStr("return s;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let q=new Array(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)q[i]=C_(c,v[i]);\n")
	do writer.writeStr("return q;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let p=t.slice(1),q=DT_(p),d={L:v.L,B:f(v.B)};\n")
	do writer.writeStr("return d;\n")
	do writer.writeStr("function f(n){\n")
	do writer.writeStr("if(n==null)return null;\n")
	do writer.writeStr("return {K:C_(p,n.K),V:C_(q,n.V),CL:f(n.CL),CR:f(n.CR),R:n.R};\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("return CT_[v.Y_+\{%copy $ \convert@MethodOffset $ int}](v);\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return v;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'repeat' implementation.
	do writer.writeStr("function R_(c,n){\n")
	do writer.writeStr("if(c.repeat)return c.repeat(n);\n")
	do writer.writeStr("let r=\"\";\n")
	do writer.writeStr("for(let i=0;i<n;i++)r+=c;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'CheckNewArray'.
	do writer.writeStr("function CNA_(n){\n")
	if(!\option@rls)
		do writer.writeStr("if(n<0)throw 0xe917000b;\n")
	end if
	do writer.writeStr("return n;\n")
	do writer.writeStr("}\n")
	
	; Get 'cmp' function.
	do writer.writeStr("function CM_(t){\n")
	do writer.writeStr("switch(t){\n")
	do writer.writeStr("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return SC_;\n")
	do writer.writeStr("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return function(a,b){return a>b?1:a<b?-1:0};\n")
	do writer.writeStr("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return UC_;\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return function(a,b){return ~~CT_[a.Y_+\{%cmp $ \convert@MethodOffset $ int}](a,b)[1]};n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; Cast from 'bit64' to 'float'.
	do writer.writeStr("function UF_(n){\n")
	do writer.writeStr("return (n[0]>>>31)*0x10000000000000000+(~~n[0]+(n[1]>>>31))*0x100000000+~~n[1]\n")
	do writer.writeStr("}\n")
	
	; Cast from 'int' to 'float'.
	do writer.writeStr("function SF_(n){\n")
	do writer.writeStr("return n[0]&0x80000000?-(~n[0]>>>31)*0x10000000000000000-(~n[0]+(~n[1]>>>31))*0x100000000-~n[1]-1:(n[0]>>>31)*0x10000000000000000+(~~n[0]+(n[1]>>>31))*0x100000000+~~n[1]\n")
	do writer.writeStr("}\n")
	
	; Cast from 'float' to 'int' or 'bit64'.
	do writer.writeStr("function NI_(n){\n")
	do writer.writeStr("return n<0?Uint32Array.from([~(-n/0x100000000)+(((-n)&0xffffffff)?0:1),~-n+1]):Uint32Array.from([~~(n/0x100000000),~~n])\n")
	do writer.writeStr("}\n")
	
	; 'compare' for 'bit64'.
	do writer.writeStr("function UC_(a,b){\n")
	do writer.writeStr("return a[0]>b[0]?1:a[0]<b[0]?-1:a[1]>b[1]?1:a[1]<b[1]?-1:0;\n")
	do writer.writeStr("}\n")
	
	; 'compare' for 'int'.
	do writer.writeStr("function SC_(a,b){\n")
	do writer.writeStr("return (a[0]&0x80000000)!=(b[0]&0x80000000)?((a[0]&0x80000000)?-1:1):a[0]>b[0]?1:a[0]<b[0]?-1:a[1]>b[1]?1:a[1]<b[1]?-1:0;\n")
	do writer.writeStr("}\n")
	
	; 'add' for 'bit64' and 'int'.
	do writer.writeStr("function NA_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x=a[1],y=b[1],z;\n")
	do writer.writeStr("r[1]=x+y;\n")
	do writer.writeStr("z=~r[1];\n")
	do writer.writeStr("r[0]=a[0]+b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; Fast 'add'.
	do writer.writeStr("function FA_(a,b){\n")
	do writer.writeStr("let x=a[1],y=b[1],z;\n")
	do writer.writeStr("a[1]+=y;\n")
	do writer.writeStr("z=~a[1];\n")
	do writer.writeStr("a[0]+=b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("}\n")
	
	; 'sub' for 'bit64' and 'int'.
	do writer.writeStr("function NS_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x=a[1],y=~b[1],z;\n")
	do writer.writeStr("r[1]=x+y+1;\n")
	do writer.writeStr("z=~r[1];\n")
	do writer.writeStr("r[0]=a[0]+~b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; Fast 'sub'.
	do writer.writeStr("function FS_(a,b){\n")
	do writer.writeStr("let x=a[1],y=~b[1],z;\n")
	do writer.writeStr("a[1]+=y+1;\n")
	do writer.writeStr("z=~a[1];\n")
	do writer.writeStr("a[0]+=~b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("}\n")
	
	; 'mul' for 'bit64'.
	do writer.writeStr("function NM_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x,y;\n")
	do writer.writeStr("if(UC_(a,b)<0){x=Uint32Array.from(b);y=Uint32Array.from(a);}else{x=Uint32Array.from(a);y=Uint32Array.from(b);}\n")
	do writer.writeStr("while(y[0]|y[1]){\n")
	do writer.writeStr("if(y[1]&1)FA_(r,x);\n")
	do writer.writeStr("y[1]>>>=1;\n")
	do writer.writeStr("y[1]|=y[0]<<31;\n")
	do writer.writeStr("y[0]>>>=1;\n")
	do writer.writeStr("x[0]<<=1;\n")
	do writer.writeStr("x[0]|=x[1]>>>31;\n")
	do writer.writeStr("x[1]<<=1;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'mul' for 'bit32'.
	do writer.writeStr("function UL_(a,b){\n")
	do writer.writeStr("let r=0,x,y;\n")
	do writer.writeStr("if(a<b){x=b;y=a}else{x=a;y=b}\n")
	do writer.writeStr("while(y){\n")
	do writer.writeStr("if(y&1)r+=x;\n")
	do writer.writeStr("y>>>=1;\n")
	do writer.writeStr("x<<=1;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'div' and 'mod' implement.
	do writer.writeStr("function DO_(a,b){\n")
	do writer.writeStr("var i=63,q=new Uint32Array(2),r=new Uint32Array(2);\n")
	do writer.writeStr("while(i>=32){\n")
	do writer.writeStr("r[0]<<=1;\n")
	do writer.writeStr("r[0]|=r[1]>>>31;\n")
	do writer.writeStr("r[1]<<=1;\n")
	do writer.writeStr("r[1]|=(a[0]>>>(i-32))&1;\n")
	do writer.writeStr("if(UC_(r,b)>=0){\n")
	do writer.writeStr("FS_(r,b);\n")
	do writer.writeStr("q[0]|=1<<(i-32);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("i--;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("while(i>=0){\n")
	do writer.writeStr("r[0]<<=1;\n")
	do writer.writeStr("r[0]|=r[1]>>>31;\n")
	do writer.writeStr("r[1]<<=1;\n")
	do writer.writeStr("r[1]|=(a[1]>>>i)&1\n")
	do writer.writeStr("if(UC_(r,b)>=0){\n")
	do writer.writeStr("FS_(r,b);\n")
	do writer.writeStr("q[1]|=1<<i;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("i--;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return[q,r];\n")
	do writer.writeStr("}\n")
	
	; 'div' for 'bit64'.
	do writer.writeStr("function UD_(a,b){return DO_(a,b)[0]}\n")
	
	; 'div' for 'int'.
	do writer.writeStr("function SD_(a,b){\n")
	do writer.writeStr("let q,x=a,y=b,sx,sy;\n")
	do writer.writeStr("if(sx=(x[0]&0x80000000)){x=Uint32Array.from([~x[0]+(x[1]?0:1),~x[1]+1])}\n")
	do writer.writeStr("if(sy=(y[0]&0x80000000)){y=Uint32Array.from([~y[0]+(y[1]?0:1),~y[1]+1])}\n")
	do writer.writeStr("q=DO_(x,y)[0];\n")
	do writer.writeStr("if(sx!=sy){q[0]=~q[0]+(q[1]?0:1);q[1]=~q[1]+1}\n")
	do writer.writeStr("return q;\n")
	do writer.writeStr("}\n")
	
	; 'mod' for 'bit64'.
	do writer.writeStr("function UO_(a,b){return DO_(a,b)[1]}\n")
	
	; 'mod' for 'int'.
	do writer.writeStr("function SO_(a,b){\n")
	do writer.writeStr("let r,x=a,y=b,sx,sy;\n")
	do writer.writeStr("if(sx=(x[0]&0x80000000)){x=Uint32Array.from([~x[0]+(x[1]?0:1),~x[1]+1])}\n")
	do writer.writeStr("if(sy=(y[0]&0x80000000)){y=Uint32Array.from([~y[0]+(y[1]?0:1),~y[1]+1])}\n")
	do writer.writeStr("r=DO_(x,y)[1];\n")
	do writer.writeStr("if(sx){r[0]=~r[0]+(r[1]?0:1);r[1]=~r[1]+1}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'pow' for 'int'.
	do writer.writeStr("function PI_(a,b){\n")
	do writer.writeStr("if(!(b[0]|b[1]))return Uint32Array.from([0,1]);\n")
	do writer.writeStr("if(!b[0]&&b[1]==1)return a;\n")
	do writer.writeStr("if(!b[0]&&b[1]==2)return NM_(a,a);\n")
	do writer.writeStr("if(!a[0]&&a[1]==1)return Uint32Array.from([0,1]);\n")
	do writer.writeStr("if(a[0]==0xffffffff&&a[1]==0xffffffff)return(b[1]&1)?Uint32Array.from([-1,-1]):Uint32Array.from([0,1]);\n")
	do writer.writeStr("if(b[1]&0x80000000)return new Uint32Array(2);\n")
	do writer.writeStr("let r=Uint32Array.from([0,1]),c=Uint32Array.from(b);\n")
	do writer.writeStr("for(;;){\n")
	do writer.writeStr("if(c[1]&1)r=NM_(r,a);\n")
	do writer.writeStr("c[1]>>>=1;\n")
	do writer.writeStr("c[1]|=c[0]<<31;\n")
	do writer.writeStr("c[0]>>>=1;\n")
	do writer.writeStr("if(!(c[0]|c[1]))break;\n")
	do writer.writeStr("a=NM_(a,a);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
end func
