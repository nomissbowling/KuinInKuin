+func write(writer: file@Writer)
	; Discard types to get the 'value' type of a dictionary.
	do writer.writeStr("function DT_(t){\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return DT_(t.slice(1));\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return DT_(DT_(t.slice(1)));\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return t.slice(1);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'add' to 'dict'.
	do writer.writeStr("function DA_(d,t,k,v){\n")
	do writer.writeStr("let a=false,m=CM_(t[1]);\n")
	do writer.writeStr("d.B=f(d.B);\n")
	do writer.writeStr("d.B.R=false;\n")
	do writer.writeStr("if(a)d.L++;\n")
	do writer.writeStr("function f(n){\n")
	do writer.writeStr("if(n==null){a=true;return{K:k,V:v,CL:null,CR:null,R:true}}\n")
	do writer.writeStr("let c=m(k,n.K);\n")
	do writer.writeStr("if(c==0){n.V=v;return n;}\n")
	do writer.writeStr("if(c<0)n.CL=f(n.CL);else n.CR=f(n.CR);\n")
	do writer.writeStr("if(n.CR!=null&&n.CR.R){\n")
	do writer.writeStr("let r=n.CR;\n")
	do writer.writeStr("n.CR=r.CL;\n")
	do writer.writeStr("r.CL=n;\n")
	do writer.writeStr("r.R=n.R;\n")
	do writer.writeStr("n.R=true;\n")
	do writer.writeStr("n=r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("if(n.CL!=null&&n.CL.R&&n.CL.CL!=null&&n.CL.CL.R){\n")
	do writer.writeStr("let l=n.CL;\n")
	do writer.writeStr("n.CL=l.CR;\n")
	do writer.writeStr("l.CR=n;\n")
	do writer.writeStr("l.R=n.R;\n")
	do writer.writeStr("n.R=true;\n")
	do writer.writeStr("n=l;\n")
	do writer.writeStr("n.R=true;\n")
	do writer.writeStr("n.CL.R=false;\n")
	do writer.writeStr("n.CR.R=false;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return n;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'tobin' implementation.
	do writer.writeStr("function TB_(t,v){\n")
	do writer.writeStr("function l(n){return[n&0xff,(n>>>8)&0xff,(n>>>16)&0xff,(n>>>24)&0xff];}\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("if(t[1]==\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let w=v.S,r=l(w.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<w.length;i++)r=r.concat(TB_(c,w[i]));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let r=l(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)r=r.concat(TB_(c,v[i]));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let p=v.H,n,i=0;\n")
	do writer.writeStr("while(p!=null){\n")
	do writer.writeStr("if(p==v.P){n=i;break;}")
	do writer.writeStr("p=p.N;i++;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("let r=l(n).concat(l(v.L)),c=t.slice(1);\n")
	do writer.writeStr("p=v.H;while(p!=null){r=r.concat(TB_(c,p.I));p=p.N;}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("let r=l(v.L),p=t.slice(1),q=DT_(p);\n")
	do writer.writeStr("f(v.B);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("function f(d){\n")
	do writer.writeStr("if(d.CL!=null)f(d.CL);\n")
	do writer.writeStr("r=r.concat(TB_(p,d.K),TB_(q,d.V));\n")
	do writer.writeStr("if(d.CR!=null)f(d.CR);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("if(v==null)return l(-1);\n")
	do writer.writeStr("return l(v.Y_).concat(CT_[v.Y_+\{%toBin $ \convert@MethodOffset $ int}](v));\n")
	do writer.writeStr("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let s1=v[0].toString(),s2=v[1].toString(),r1=new Array(s1.length*2),r2=new Array(s2.length*2),c;\n")
	do writer.writeStr("for(let i=0;i<s1.length;i++){c=s1.charCodeAt(i);r1[i*2]=c&0xff;r1[i*2+1]=(c>>>8)&0xff;}\n")
	do writer.writeStr("for(let i=0;i<s2.length;i++){c=s2.charCodeAt(i);r2[i*2]=c&0xff;r2[i*2+1]=(c>>>8)&0xff;}\n")
	do writer.writeStr("return l(s1.length).concat(l(s2.length),r1,r2);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let s=v.toString(),r=new Array(s.length*2),c;\n")
	do writer.writeStr("for(let i=0;i<s.length;i++){c=s.charCodeAt(i);r[i*2]=c&0xff;r[i*2+1]=(c>>>8)&0xff;}\n")
	do writer.writeStr("return l(s.length).concat(r);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'frombin' implementation.
	do writer.writeStr("function FB_(t,b,o){\n")
	do writer.writeStr("function l(b,o){let r=b[o.$[1]]|(b[o.$[1]+1]<<8)|(b[o.$[1]+2]<<16)|(b[o.$[1]+3]<<24);o.$[1]+=4;return r;}\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("if(t[1]==\{%char_ $ \convert@RuntimeTypeId $ int}){\n")
	do writer.writeStr("let r=\"\",c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++)r+=FB_(c,b,o);\n")
	do writer.writeStr("return{S:r};\n")
	do writer.writeStr("}else{\n")
	do writer.writeStr("let r=new Array(n),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++)r[i]=FB_(c,b,o);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let p=l(b,o),n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("let r={L:n,H:null,T:null,P:null},c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++){\n")
	do writer.writeStr("let m={P:null,N:null,I:FB_(c,b,o)};\n")
	do writer.writeStr("if(r.H==null){r.H=m;r.T=m;}else{m.P=r.T;r.T.N=m;r.T=m;}\n")
	do writer.writeStr("if(i==p)r.P=m;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("let r=[],c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<n;i++)r.push(FB_(c,b,o));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o);if(n==-1)return null;\n")
	do writer.writeStr("let r={L:0,B:null},p=t.slice(1),q=DT_(p);\n")
	do writer.writeStr("for(let i=0;i<n;i++)\n")
	do writer.writeStr("DA_(r,t,FB_(p,b,o),FB_(q,b,o));\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let y=l(b,o);if(y==-1)return null;\n")
	do writer.writeStr("return CT_[y+\{%fromBin $ \convert@MethodOffset $ int}](null,b,o);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n1=l(b,o),n2=l(b,o),s1=\"\",s2=\"\";\n")
	do writer.writeStr("for(let i=0;i<n1;i++){s1+=String.fromCharCode(b[o.$[1]]|(b[o.$[1]+1]<<8));o.$[1]+=2;}\n")
	do writer.writeStr("for(let i=0;i<n2;i++){s2+=String.fromCharCode(b[o.$[1]]|(b[o.$[1]+1]<<8));o.$[1]+=2;}\n")
	do writer.writeStr("return Uint32Array.from([parseInt(s1,10),parseInt(s2,10)]);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("let n=l(b,o),s=\"\";\n")
	do writer.writeStr("for(let i=0;i<n;i++){s+=String.fromCharCode(b[o.$[1]]|(b[o.$[1]+1]<<8));o.$[1]+=2;}\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%float_ $ \convert@RuntimeTypeId $ int}:return parseFloat(s);\n")
	do writer.writeStr("case \{%char_ $ \convert@RuntimeTypeId $ int}:return s;\n")
	do writer.writeStr("case \{%bool_ $ \convert@RuntimeTypeId $ int}:return s==\"true\";\n")
	do writer.writeStr("default:return parseInt(s);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'copy' implementation.
	do writer.writeStr("function C_(t,v){\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(t[1]==\{%char_ $ \convert@RuntimeTypeId $ int})\n")
	do writer.writeStr("return v==null?null:{S:v.S};\n")
	do writer.writeStr("else{\n")
	do writer.writeStr("let a=new Array(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)a[i]=C_(c,v[i]);\n")
	do writer.writeStr("return a;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let l={L:v.L,H:null,T:null,P:null},p=v.H,c=t.slice(1);\n")
	do writer.writeStr("while(p!=null){\n")
	do writer.writeStr("let n={P:null,N:null,I:C_(c,p.I)};\n")
	do writer.writeStr("if(l.H==null){l.H=n;l.T=n;}else{n.P=l.T;l.T.N=n;l.T=n;}\n")
	do writer.writeStr("if(p==v.P)l.P=n;\n")
	do writer.writeStr("p=p.N;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return l;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%stack_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let s=new Array(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)s[i]=C_(c,v[i]);\n")
	do writer.writeStr("return s;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%queue_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let q=new Array(v.length),c=t.slice(1);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)q[i]=C_(c,v[i]);\n")
	do writer.writeStr("return q;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%dict_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("{\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("let p=t.slice(1),q=DT_(p),d={L:v.L,B:f(v.B)};\n")
	do writer.writeStr("return d;\n")
	do writer.writeStr("function f(n){\n")
	do writer.writeStr("if(n==null)return null;\n")
	do writer.writeStr("return {K:C_(p,n.K),V:C_(q,n.V),CL:f(n.CL),CR:f(n.CR),R:n.R};\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("if(v==null)return null;\n")
	do writer.writeStr("return CT_[v.Y_+\{%copy $ \convert@MethodOffset $ int}](v);\n")
	do writer.writeStr("default:\n")
	do writer.writeStr("return v;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; 'repeat' implementation.
	do writer.writeStr("function R_(c,n){\n")
	do writer.writeStr("if(c.repeat)return c.repeat(n);\n")
	do writer.writeStr("let r=\"\";\n")
	do writer.writeStr("for(let i=0;i<n;i++)r+=c;\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; Get 'cmp' function.
	do writer.writeStr("function CM_(t){\n")
	do writer.writeStr("switch(t){\n")
	do writer.writeStr("case \{%int_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return SC_;\n")
	do writer.writeStr("case \{%float_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%char_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit8_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit16_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit32_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return function(a,b){return a>b?1:a<b?-1:0};\n")
	do writer.writeStr("case \{%bit64_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return UC_;\n")
	do writer.writeStr("case \{%array $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\n")
	do writer.writeStr("case \{%class_ $ \convert@RuntimeTypeId $ int}:\n")
	do writer.writeStr("return function(a,b){return ~~CT_[a.Y_+\{%cmp $ \convert@MethodOffset $ int}](a,b)[1]};n")
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	; Cast from 'bit64' to 'float'.
	do writer.writeStr("function UF_(n){\n")
	do writer.writeStr("return (n[0]>>>31)*0x10000000000000000+(~~n[0]+(n[1]>>>31))*0x100000000+~~n[1]\n")
	do writer.writeStr("}\n")
	
	; Cast from 'int' to 'float'.
	do writer.writeStr("function SF_(n){\n")
	do writer.writeStr("return n[0]&0x80000000?-(~n[0]>>>31)*0x10000000000000000-(~n[0]+(~n[1]>>>31))*0x100000000-~n[1]-1:(n[0]>>>31)*0x10000000000000000+(~~n[0]+(n[1]>>>31))*0x100000000+~~n[1]\n")
	do writer.writeStr("}\n")
	
	; Cast from 'float' to 'int' or 'bit64'.
	do writer.writeStr("function NI_(n){\n")
	do writer.writeStr("return n<0?Uint32Array.from([~(-n/0x100000000)+(((-n)&0xffffffff)?0:1),~-n+1]):Uint32Array.from([~~(n/0x100000000),~~n])\n")
	do writer.writeStr("}\n")
	
	; 'compare' for 'bit64'.
	do writer.writeStr("function UC_(a,b){\n")
	do writer.writeStr("return a[0]>b[0]?1:a[0]<b[0]?-1:a[1]>b[1]?1:a[1]<b[1]?-1:0;\n")
	do writer.writeStr("}\n")
	
	; 'compare' for 'int'.
	do writer.writeStr("function SC_(a,b){\n")
	do writer.writeStr("return (a[0]&0x80000000)!=(b[0]&0x80000000)?((a[0]&0x80000000)?-1:1):a[0]>b[0]?1:a[0]<b[0]?-1:a[1]>b[1]?1:a[1]<b[1]?-1:0;\n")
	do writer.writeStr("}\n")
	
	; 'add' for 'bit64' and 'int'.
	do writer.writeStr("function NA_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x=a[1],y=b[1],z;\n")
	do writer.writeStr("r[1]=x+y;\n")
	do writer.writeStr("z=~r[1];\n")
	do writer.writeStr("r[0]=a[0]+b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; Fast 'add'.
	do writer.writeStr("function FA_(a,b){\n")
	do writer.writeStr("let x=a[1],y=b[1],z;\n")
	do writer.writeStr("a[1]+=y;\n")
	do writer.writeStr("z=~a[1];\n")
	do writer.writeStr("a[0]+=b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("}\n")
	
	; 'sub' for 'bit64' and 'int'.
	do writer.writeStr("function NS_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x=a[1],y=~b[1],z;\n")
	do writer.writeStr("r[1]=x+y+1;\n")
	do writer.writeStr("z=~r[1];\n")
	do writer.writeStr("r[0]=a[0]+~b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; Fast 'sub'.
	do writer.writeStr("function FS_(a,b){\n")
	do writer.writeStr("let x=a[1],y=~b[1],z;\n")
	do writer.writeStr("a[1]+=y+1;\n")
	do writer.writeStr("z=~a[1];\n")
	do writer.writeStr("a[0]+=~b[0]+(((x&y)|((x|y)&z))>>>31);\n")
	do writer.writeStr("}\n")
	
	; 'mul' for 'bit64'.
	do writer.writeStr("function UM_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x,y;\n")
	do writer.writeStr("if(UC_(a,b)<0){x=Uint32Array.from(b);y=Uint32Array.from(a);}else{x=Uint32Array.from(a);y=Uint32Array.from(b);}\n")
	do writer.writeStr("while(y[0]|y[1]){\n")
	do writer.writeStr("if(y[1]&1)FA_(r,x);\n")
	do writer.writeStr("y[1]>>>=1;\n")
	do writer.writeStr("y[1]|=y[0]<<31;\n")
	do writer.writeStr("y[0]>>>=1;\n")
	do writer.writeStr("x[0]<<=1;\n")
	do writer.writeStr("x[0]|=x[1]>>>31;\n")
	do writer.writeStr("x[1]<<=1;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; TODO: Remove 'SM_'.
	; 'mul' for 'int'.
	do writer.writeStr("function SM_(a,b){\n")
	do writer.writeStr("let r=new Uint32Array(2),x,y,sx,sy;\n")
	do writer.writeStr("if(UC_(a,b)<0){x=Uint32Array.from(b);y=Uint32Array.from(a)}else{x=Uint32Array.from(a);y=Uint32Array.from(b)}\n")
	do writer.writeStr("if(sx=(x[0]&0x80000000)){x[0]=~x[0]+(x[1]?0:1);x[1]=~x[1]+1}\n")
	do writer.writeStr("if(sy=(y[0]&0x80000000)){y[0]=~y[0]+(y[1]?0:1);y[1]=~y[1]+1}\n")
	do writer.writeStr("while(y[0]|y[1]){\n")
	do writer.writeStr("if(y[1]&1)FA_(r,x);\n")
	do writer.writeStr("y[1]>>>=1;\n")
	do writer.writeStr("y[1]|=y[0]<<31;\n")
	do writer.writeStr("y[0]>>>=1;\n")
	do writer.writeStr("x[0]<<=1;\n")
	do writer.writeStr("x[0]|=x[1]>>>31;\n")
	do writer.writeStr("x[1]<<=1;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("if(sx!=sy){r[0]=~r[0]+(r[1]?0:1);r[1]=~r[1]+1}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'mul' for 'bit32'.
	do writer.writeStr("function UL_(a,b){\n")
	do writer.writeStr("let r=0,x,y;\n")
	do writer.writeStr("if(a<b){x=b;y=a}else{x=a;y=b}\n")
	do writer.writeStr("while(y){\n")
	do writer.writeStr("if(y&1)r+=x;\n")
	do writer.writeStr("y>>>=1;\n")
	do writer.writeStr("x<<=1;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'div' and 'mod' implement.
	do writer.writeStr("function DO_(a,b){\n")
	do writer.writeStr("var i=63,q=new Uint32Array(2),r=new Uint32Array(2);\n")
	do writer.writeStr("while(i>=32){\n")
	do writer.writeStr("r[0]<<=1;\n")
	do writer.writeStr("r[0]|=r[1]>>>31;\n")
	do writer.writeStr("r[1]<<=1;\n")
	do writer.writeStr("r[1]|=(a[0]>>>(i-32))&1;\n")
	do writer.writeStr("if(UC_(r,b)>=0){\n")
	do writer.writeStr("FS_(r,b);\n")
	do writer.writeStr("q[0]|=1<<(i-32);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("i--;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("while(i>=0){\n")
	do writer.writeStr("r[0]<<=1;\n")
	do writer.writeStr("r[0]|=r[1]>>>31;\n")
	do writer.writeStr("r[1]<<=1;\n")
	do writer.writeStr("r[1]|=(a[1]>>>i)&1\n")
	do writer.writeStr("if(UC_(r,b)>=0){\n")
	do writer.writeStr("FS_(r,b);\n")
	do writer.writeStr("q[1]|=1<<i;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("i--;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return[q,r];\n")
	do writer.writeStr("}\n")
	
	; 'div' for 'bit64'.
	do writer.writeStr("function UD_(a,b){return DO_(a,b)[0]}\n")
	
	; 'div' for 'int'.
	do writer.writeStr("function SD_(a,b){\n")
	do writer.writeStr("let q,x=a,y=b,sx,sy;\n")
	do writer.writeStr("if(sx=(x[0]&0x80000000)){x=Uint32Array.from([~x[0]+(x[1]?0:1),~x[1]+1])}\n")
	do writer.writeStr("if(sy=(y[0]&0x80000000)){y=Uint32Array.from([~y[0]+(y[1]?0:1),~y[1]+1])}\n")
	do writer.writeStr("q=DO_(x,y)[0];\n")
	do writer.writeStr("if(sx!=sy){q[0]=~q[0]+(q[1]?0:1);q[1]=~q[1]+1}\n")
	do writer.writeStr("return q;\n")
	do writer.writeStr("}\n")
	
	; 'mod' for 'bit64'.
	do writer.writeStr("function UO_(a,b){return DO_(a,b)[1]}\n")
	
	; 'mod' for 'int'.
	do writer.writeStr("function SO_(a,b){\n")
	do writer.writeStr("let r,x=a,y=b,sx,sy;\n")
	do writer.writeStr("if(sx=(x[0]&0x80000000)){x=Uint32Array.from([~x[0]+(x[1]?0:1),~x[1]+1])}\n")
	do writer.writeStr("if(sy=(y[0]&0x80000000)){y=Uint32Array.from([~y[0]+(y[1]?0:1),~y[1]+1])}\n")
	do writer.writeStr("r=DO_(x,y)[1];\n")
	do writer.writeStr("if(sx){r[0]=~r[0]+(r[1]?0:1);r[1]=~r[1]+1}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
	
	; 'pow' for 'int'.
	do writer.writeStr("function PI_(a,b){\n")
	do writer.writeStr("if(!(b[0]|b[1]))return Uint32Array.from([0,1]);\n")
	do writer.writeStr("if(!b[0]&&b[1]==1)return a;\n")
	do writer.writeStr("if(!b[0]&&b[1]==2)return SM_(a,a);\n")
	do writer.writeStr("if(!a[0]&&a[1]==1)return Uint32Array.from([0,1]);\n")
	do writer.writeStr("if(a[0]==0xffffffff&&a[1]==0xffffffff)return(b[1]&1)?Uint32Array.from([-1,-1]):Uint32Array.from([0,1]);\n")
	do writer.writeStr("if(b[1]&0x80000000)return new Uint32Array(2);\n")
	do writer.writeStr("let r=Uint32Array.from([0,1]),c=Uint32Array.from(b);\n")
	do writer.writeStr("for(;;){\n")
	do writer.writeStr("if(c[1]&1)r=SM_(r,a);\n")
	do writer.writeStr("c[1]>>>=1;\n")
	do writer.writeStr("c[1]|=c[0]<<31;\n")
	do writer.writeStr("c[0]>>>=1;\n")
	do writer.writeStr("if(!(c[0]|c[1]))break;\n")
	do writer.writeStr("a=SM_(a,a);\n")
	do writer.writeStr("}\n")
	do writer.writeStr("return r;\n")
	do writer.writeStr("}\n")
end func
