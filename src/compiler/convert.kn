+enum RuntimeTypeId
	int_
	float_
	char_
	bool_
	bit8_
	bit16_
	bit32_
	bit64_
	func_
	enum_
	ref :: 0x80
	array
	list_
	stack_
	queue_
	dict_
	class_
end enum

+enum MethodOffset
	ctor :: 1
	dtor
	cmp
	copy
	toBin
	fromBin
	toStr
end enum

+func getTypeId(type: \ast@AstType): list<int>
	var result: list<int> :: #list<int>
	do @makeTypeIdRecursion(type, result)
	ret result
end func

func makeTypeIdRecursion(type: \ast@AstType, output: list<int>)
	if(\ast@isInt(type))
		do output.add(%int_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isFloat(type))
		do output.add(%float_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isChar(type))
		do output.add(%char_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isBool(type))
		do output.add(%bool_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(type.typeId = %typeBit)
		switch((type $ \ast@AstTypeBit).size)
		case 1
			do output.add(%bit8_ $ @RuntimeTypeId $ int)
		case 2
			do output.add(%bit16_ $ @RuntimeTypeId $ int)
		case 4
			do output.add(%bit32_ $ @RuntimeTypeId $ int)
		case 8
			do output.add(%bit64_ $ @RuntimeTypeId $ int)
		default
			assert false
		end switch
		ret
	end if
	if(type.typeId = %typeFunc)
		do output.add(%func_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(\ast@isEnum(type))
		do output.add(%enum_ $ @RuntimeTypeId $ int)
		ret
	end if
	if(type.typeId = %typeArray)
		do output.add(%array $ @RuntimeTypeId $ int)
		do @makeTypeIdRecursion((type $ \ast@AstTypeArray).itemType, output)
		ret
	end if
	if(type.typeId = %typeGen)
		switch((type $ \ast@AstTypeGen).kind)
		case %list_
			do output.add(%list_ $ @RuntimeTypeId $ int)
		case %stack_
			do output.add(%stack_ $ @RuntimeTypeId $ int)
		case %queue_
			do output.add(%queue_ $ @RuntimeTypeId $ int)
		default
			assert false
		end switch
		do @makeTypeIdRecursion((type $ \ast@AstTypeGen).itemType, output)
		ret
	end if
	if(type.typeId = %typeDict)
		do output.add(%dict_ $ @RuntimeTypeId $ int)
		do @makeTypeIdRecursion((type $ \ast@AstTypeDict).itemTypeKey, output)
		do @makeTypeIdRecursion((type $ \ast@AstTypeDict).itemTypeValue, output)
		ret
	end if
	assert \ast@isClass(type)
	do output.add(%class_ $ @RuntimeTypeId $ int)
end func

+func parseExcode(ast: \ast@AstStatExcode, func_: \ast@AstFunc, getIdCodeFunc: func<(\ast@AstArg): []char>): []char
	var ptr: int :: 0
	var code: []char :: (ast.code $ \ast@AstExprValueStr).value
	var s: []char :: ""
	var funcArgs: list<\ast@AstArg> :: func_.args
	var listPtr: kuin@ListPtr :: funcArgs.getPtr()
	var args: []\ast@AstArg :: #[^funcArgs]\ast@AstArg
	do funcArgs.head()
	for i(0, ^args - 1)
		do args[i] :: funcArgs.get()
		do funcArgs.next()
	end for
	do funcArgs.setPtr(listPtr)
	while(ptr < ^code)
		var pos: int :: code.find('`', ptr)
		if(pos = ptr)
			do ptr :+ 1
			var value: []char :: parseValue(code, &ptr)
			if(^value >= 1 & value[0] = '.')
				var class_: \ast@AstClass :: null
				if(func_.funcOption.and(%any) = %none & ^args >= 1 & args[0].type.refItem <>& null & args[0].type.refItem.typeId = %class_)
					do class_ :: (args[0].type.refItem $ \ast@AstClass)
				elif(func_.funcOption.and(%any) <> %none & ^args >= 3 & args[2].type.refItem <>& null & args[2].type.refItem.typeId = %class_)
					do class_ :: (args[2].type.refItem $ \ast@AstClass)
				end if
				if(class_ <>& null)
					var name: []char :: value.sub(1, -1)
					var members: list<\ast@AstClassItem> :: class_.items
					do members.head()
					while loop(!members.term())
						var def: \ast@Ast :: members.get().def
						if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
							do s :~ getIdCodeFunc((def $ \ast@AstVar).arg)
							break loop
						end if
						do members.next()
					end while
				end if
			else
				var success: bool
				var value2: int :: value.toInt(&success)
				if(success & value2 < ^args)
					do s :~ getIdCodeFunc(args[value2])
				end if
			end if
		elif(pos = -1)
			do s :~ code.sub(ptr, -1)
			do ptr :: ^code
		else
			do s :~ code.sub(ptr, pos - ptr)
			do ptr :: pos
		end if
	end while
	ret s
	
	func parseValue(code: []char, ptr: &int): []char
		var pos: int :: code.find('`', ptr)
		var value: []char
		if(pos = -1)
			do value :: code.sub(ptr, -1)
			do ptr :: ^code
		else
			do value :: code.sub(ptr, pos - ptr)
			do ptr :: pos + 1
		end if
		ret value
	end func
end func

+func bit16ToBin(n: bit16): []bit8
	ret[n $ bit8, n.shr(8) $ bit8]
end func

+func bit32ToBin(n: bit32): []bit8
	ret[n $ bit8, n.shr(8) $ bit8, n.shr(16) $ bit8, n.shr(24) $ bit8]
end func

+func bit64ToBin(n: bit64): []bit8
	ret[n $ bit8, n.shr(8) $ bit8, n.shr(16) $ bit8, n.shr(24) $ bit8, n.shr(32) $ bit8, n.shr(40) $ bit8, n.shr(48) $ bit8, n.shr(56) $ bit8]
end func
