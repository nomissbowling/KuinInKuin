+func write(codes: list<[]char>, attr: []char, args: list<\ast@AstArg>, members: list<\ast@AstClassItem>)
	switch(attr)
	case "acos"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::acos(\{x.id});\n")
	case "acosh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::acosh(\{x.id});\n")
	case "addr"
		do args.head()
		var class_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return reinterpret_cast<uint64_t>(\{class_.id});\n")
	case "addDict"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->Add(\{key.id}, \{item.id});\n")
	case "addList"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push_back(\{item.id});\n")
	case "addQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push(\{item.id});\n")
	case "addStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push(\{item.id});\n")
	case "and"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} & \{n.id};\n")
	case "asin"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::asin(\{x.id});\n")
	case "asinh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::asinh(\{x.id});\n")
	case "atan"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::atan(\{x.id});\n")
	case "atanh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::atanh(\{x.id});\n")
	case "ceil"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::ceil(\{x.id});\n")
	case "cmdLine"
		do codes.add("Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\n")
		do codes.add("a_->L = argc_;\n")
		do codes.add("a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\n")
		do codes.add("for (int64_t i_ = 0; i_ < argc_; i_++){\n")
		do codes.add("std::string s_ = argv_[i_];\n")
		do codes.add("const std::u16string t_ = utf8ToUtf16_(s_);\n")
		do codes.add("a_->B[i_] = new Array_<char16_t>();\n")
		do codes.add("a_->B[i_]->L = static_cast<int64_t>(t_.size());\n")
		do codes.add("a_->B[i_]->B = new char16_t[t_.size() + 1];\n")
		do codes.add("std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\n")
		do codes.add("}\n")
		do codes.add("return a_;\n")
	case "cos"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::cos(\{x.id});\n")
	case "cosh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::cosh(\{x.id});\n")
	case "del"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("auto i_ = \{me_.id}->I++;\n")
		do codes.add("\{me_.id}->B.erase(i_);\n")
	case "dist"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var y: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerX: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerY: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::hypot(\{x.id} - \{centerX.id}, \{y.id} - \{centerY.id});\n")
	case "endian"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return endian_(\{me_.id});\n")
	case "exp"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::exp(\{x.id});\n")
	case "fill"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var value: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("for(int64_t i_ = 0; i_ < \{me_.id}->L; i_++) \{me_.id}->B[i_] = \{value.id};\n")
	case "findArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{start.id} == -1) \{start.id} = 0;\n")
		do codes.add("if(\{start.id} < 0) return -1;\n")
		do codes.add("for(int64_t i_ = \{start.id}; i_ < \{me_.id}->L; i_++){\n")
		do codes.add("if(\{me_.id}->B[i_] == \{item.id}) return i_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "findBin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("int64_t a_ = 0, b_ = \{me_.id}->L - 1;\n")
		do codes.add("while (a_ <= b_) {\n")
		do codes.add("int64_t c_ = (a_ + b_) / 2;\n")
		do codes.add("int64_t m_ = cmp_(\{item.id}, \{me_.id}->B[c_]);\n")
		do codes.add("if(m_ < 0) b_ = c_ - 1;\n")
		do codes.add("else if(m_ > 0) a_ = c_ + 1;\n")
		do codes.add("else return c_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "findLastArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{start.id} == -1) \{start.id} = \{me_.id}->L - 1;\n")
		do codes.add("if(\{start.id} >= \{me_.id}->L) return -1;\n")
		do codes.add("for(int64_t i_ = \{start.id}; i_ >= 0; i_--){\n")
		do codes.add("if(\{me_.id}->B[i_] == \{item.id}) return i_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "floor"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::floor(\{x.id});\n")
	case "forEach"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var callback: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var data: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictForEach_(\{me_.id}->B, reinterpret_cast<bool(*)(K_, V_, Class_*)>(\{callback.id}), \{data.id});\n")
	case "getDict"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var existed: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictSearch_(\{me_.id}->B, \{key.id}, \{existed.id});\n")
	case "exist"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("bool exist=false;auto _=dictSearch_(\{me_.id}->B, \{key.id}, &exist);return exist;\n")
	case "getList"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return *\{me_.id}->I;\n")
	case "getQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("R_ r_ = \{me_.id}->B.front();\n")
		do codes.add("\{me_.id}->B.pop();\n")
		do codes.add("return r_;\n")
	case "getStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("R_ r_ = \{me_.id}->B.top();\n")
		do codes.add("\{me_.id}->B.pop();\n")
		do codes.add("return r_;\n")
	case "head"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->I = \{me_.id}->B.begin();\n")
	case "idx"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("int64_t i_ = 0;\n")
		do codes.add("for(auto t_ = \{me_.id}->B.begin(); t_ != \{me_.id}->B.end(); ++t_){\n")
		do codes.add("if(t_ == \{me_.id}->I) return i_;\n")
		do codes.add("i_++;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "ins"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.insert(\{me_.id}->I, \{item.id});\n")
	case "invRot"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var y: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerX: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerY: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("double r_ = std::atan2(\{y.id} - \{centerY.id}, \{x.id} - \{centerX.id});\n")
		do codes.add("return r_ < 0.0 ? r_ + 2.0 * 3.14159265358979323846 : r_;\n")
	case "ln"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::log(\{x.id});\n")
	case "max"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do codes.add("auto r_=\{me_.id}->B[0]; for(int64_t i_ = 1; i_ < \{me_.id}->L; i_++) r_=std::max(r_,\{me_.id}->B[i_]); return r_;\n")
	case "min"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do codes.add("auto r_=\{me_.id}->B[0]; for(int64_t i_ = 1; i_ < \{me_.id}->L; i_++) r_=std::min(r_,\{me_.id}->B[i_]); return r_;\n")
	case "repeat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var len_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("typedef typename std::remove_reference<decltype(\{me_.id}->B[0])>::type Elem_;\n")
		do codes.add("Array_<Elem_> *r_=new Array_<Elem_>(); r_->L=\{me_.id}->L*\{len_.id}; r_->B=new Elem_[r_->L+1]; r_->B[r_->L]=0;\n")
		do codes.add("for(int64_t j_=0;j_<\{len_.id};j_++)for(int64_t i_=0;i_<\{me_.id}->L;i_++)r_->B[j_*\{me_.id}->L + i_]=\{me_.id}->B[i_]; return r_;\n")
	case "moveOffset"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var offset: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{offset.id} >= 0){\n")
		do codes.add("for(int64_t i_ = 0; i_ < \{offset.id}; i_++){\n")
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.end()) break;\n")
		do codes.add("++\{me_.id}->I;\n")
		do codes.add("}\n")
		do codes.add("}else{\n")
		do codes.add("for(int64_t i_ = 0; i_ > \{offset.id}; i_--){\n")
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.end()) break;\n")
		do codes.add("--\{me_.id}->I;\n")
		do codes.add("}\n")
		do codes.add("}\n")
	case "next"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("++\{me_.id}->I;\n")
	case "not"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return ~\{me_.id};\n")
	case "now"
		do codes.add("return std::time(nullptr);\n")
	case "or"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} | \{n.id};\n")
	case "peekQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->B.front();\n")
	case "peekStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->B.top();\n")
	case "prev"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.begin())\n")
		do codes.add("\{me_.id}->I = \{me_.id}->B.end();\n")
		do codes.add("else\n")
		do codes.add("--\{me_.id}->I;\n")
	case "reverse"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("reverse_(\{me_.id});\n")
	case "rnd"
		do args.head()
		var min: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var max: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return rnd_(\{min.id}, \{max.id});\n")
	case "rndFloat"
		do args.head()
		var min: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var max: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return rndFloat_(\{min.id}, \{max.id});\n")
	case "rndRaw"
		do codes.add("return (int64_t)xs128_();\n")
	case "sar"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		; TODO: sign
		do codes.add("return sar_(\{me_.id}, \{n.id});\n")
	case "shl"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} << \{n.id};\n")
	case "shr"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} >> \{n.id};\n")
	case "sin"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::sin(\{x.id});\n")
	case "sinh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::sinh(\{x.id});\n")
	case "sortArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("sort_(\{me_.id});\n")
	case "sqrt"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::sqrt(\{x.id});\n")
	case "sub"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var len: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return sub_(\{me_.id}, \{start.id}, \{len.id});\n")
	case "sysTime"
		do codes.add("return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n")
	case "tail"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->I = \{me_.id}->B.end();\n")
		do codes.add("--\{me_.id}->I;\n")
	case "tan"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::tan(\{x.id});\n")
	case "tanh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::tanh(\{x.id});\n")
	case "term"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->I == \{me_.id}->B.end();\n")
	case "toArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return toArray_<C_>(\{me_.id});")
	case "toBit64"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("uint64_t v_ = t_.size() > 2 && t_[0] == '0' && t_[1] == 'x' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toFloat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("double v_ = std::stod(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toInt"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("int64_t v_ = t_.size() > 2 && t_[0] == '0' && t_[1] == 'x' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toStr"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return toStr_(\{me_.id});\n")
	case "xor"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} ^ \{n.id};\n")
	case "cui_print"
		do args.head()
		var str: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{str.id} == nullptr){\n")
		do codes.add("std::cout << \"(null)\";\n")
		do codes.add("return;\n")
		do codes.add("}\n")
		do codes.add("std::u16string s_ = \{str.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("std::cout << t_ << std::flush;\n")
	case "cui_inputLetter"
		do codes.add("wchar_t c_ = ReadIo_();\n")
		;do codes.add("if (c_ == WEOF)\n")
		;do codes.add("throw \{excpt@invalidDataFmt $ bit32}U;\n")
		do codes.add("return (char16_t)c_;\n")
	case "toStrFmtInt"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var fmt_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(fmt == NULL, EXCPT_ACCESS_VIOLATION);\n")
		do codes.add("const char16_t* fmt2 = \{fmt_.id}->B;\n")
		do codes.add("int src_len = \{fmt_.id}->L;\n")
		do codes.add("wchar_t dst[33];\n")
		do codes.add("int dst_ptr = 0;\n")
		do codes.add("int src_ptr = 0;\n")
		do codes.add("\n")
		do codes.add("dst[dst_ptr] = L'%';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'+' || fmt2[src_ptr] == L' '))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'-' || fmt2[src_ptr] == L'0'))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && L'1' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("while (src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (!(src_ptr < src_len && (fmt2[src_ptr] == L'd' || fmt2[src_ptr] == L'x' || fmt2[src_ptr] == L'X' || fmt2[src_ptr] == L'u' || fmt2[src_ptr] == L'o')))\n")
		do codes.add("return NULL;\n")
		do codes.add("/* Windows 7 (or later) accepts ll (as well as I64).*/\n")
		do codes.add("dst[dst_ptr] = L'l';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = L'l';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = L'\\0';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("//assert(src_ptr + 1 == src_len);\n")
		do codes.add("\n")
		do codes.add("wchar_t str[65];\n")
		do codes.add("int len = swprintf(str, 65, dst, \{me_.id});\n")
		do codes.add("//assert(len < 65);\n")
		do codes.add("Array_<char16_t> *result = new Array_<char16_t>();\n")
		do codes.add("result->B = new char16_t[len+1];\n")
		do codes.add("for(int i=0;i<len;i++)result->B[i]=str[i];\n")
		do codes.add("result->B[len]=0;\n")
		do codes.add("result->L=len;\n")
		do codes.add("return result;\n")
	case "toStrFmtFloat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var fmt_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(fmt == NULL, EXCPT_ACCESS_VIOLATION);\n")
		do codes.add("const char16_t* fmt2 = \{fmt_.id}->B;\n")
		do codes.add("int src_len = \{fmt_.id}->L;\n")
		do codes.add("wchar_t dst[33];\n")
		do codes.add("int dst_ptr = 0;\n")
		do codes.add("int src_ptr = 0;\n")
		do codes.add("\n")
		do codes.add("dst[dst_ptr] = L'%';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'+' || fmt2[src_ptr] == L' '))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'-' || fmt2[src_ptr] == L'0'))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && L'1' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("while (src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && fmt2[src_ptr] == L'.')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("if (!(src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9'))\n")
		do codes.add("return NULL;\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("while (src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (!(src_ptr < src_len && (fmt2[src_ptr] == L'f' || fmt2[src_ptr] == L'e' || fmt2[src_ptr] == L'E' || fmt2[src_ptr] == L'g' || fmt2[src_ptr] == L'G' || fmt2[src_ptr] == L'a' || fmt2[src_ptr] == L'A')))\n")
		do codes.add("return NULL;\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = L'\\0';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("//assert(src_ptr + 1 == src_len);\n")
		do codes.add("\n")
		do codes.add("wchar_t str[65];\n")
		do codes.add("int len = swprintf(str, 65, dst, \{me_.id});\n")
		do codes.add("//assert(len < 65);\n")
		do codes.add("Array_<char16_t> *result = new Array_<char16_t>();\n")
		do codes.add("result->B = new char16_t[len+1];\n")
		do codes.add("for(int i=0;i<len;i++)result->B[i]=str[i];\n")
		do codes.add("result->B[len]=0;\n")
		do codes.add("result->L=len;\n")
	case "math_gamma"
		do args.head()
		var n_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return tgamma(\{n_.id});\n")
	case "math_dijkstra"
		do args.head()
		var from_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var to_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var values_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var begin_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(*(int64_t*)((U8*)from_nodes + 0x08) != *(int64_t*)((U8*)to_nodes + 0x08) || *(int64_t*)((U8*)to_nodes + 0x08) != *(int64_t*)((U8*)values + 0x08), EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("//THROWDBG(node_num <= 0 || begin_node < 0 || node_num <= begin_node, EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("const int64_t* from_nodes2 = \{from_nodes_.id}->B;\n")
		do codes.add("const int64_t* to_nodes2 = \{to_nodes_.id}->B;\n")
		do codes.add("const int64_t* values2 = \{values_.id}->B;\n")
		do codes.add("int64_t len = \{from_nodes_.id}->L;\n")
		do codes.add("int64_t i;\n")
		do codes.add("//for (i = 0; i < len; i++)\n")
		do codes.add("//\tTHROWDBG(from_nodes2[i] < 0 || node_num <= from_nodes2[i] || to_nodes2[i] < 0 || node_num <= to_nodes2[i] || values2[i] < 0, EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("\n")
		do codes.add("Array_<int64_t> *result=new Array_<int64_t>();\n")
		do codes.add("result->L = node_num;\n")
		do codes.add("result->B = new int64_t[node_num+1];\n")
		do codes.add("int64_t* distance = result->B;\n")
		do codes.add("for (i = 0; i < node_num; i++)\n")
		do codes.add("distance[i] = LLONG_MAX;\n")
		do codes.add("distance[\{begin_nodes_.id}] = 0;\n")
		do codes.add("\n")
		do codes.add("int64_t* heap = (int64_t*)malloc(sizeof(int64_t) * (2 * (size_t)(node_num * len) + 2));\n")
		do codes.add("int heap_cnt = 1;\n")
		do codes.add("heap[0] = begin_node;\n")
		do codes.add("heap[1] = 0;\n")
		do codes.add("while (heap_cnt > 0)\n")
		do codes.add("{\n")
		do codes.add("int64_t item_node = heap[0];\n")
		do codes.add("int64_t item_value = heap[1];\n")
		do codes.add("heap_cnt--;\n")
		do codes.add("heap[0] = heap[heap_cnt * 2];\n")
		do codes.add("heap[1] = heap[heap_cnt * 2 + 1];\n")
		do codes.add("{\n")
		do codes.add("int64_t del_idx = 0;\n")
		do codes.add("for (; ; )\n")
		do codes.add("{\n")
		do codes.add("if ((del_idx + 1) * 2 - 1 < heap_cnt && heap[del_idx * 2 + 1] > heap[((del_idx + 1) * 2 - 1) * 2 + 1])\n")
		do codes.add("{\n")
		do codes.add("int64_t tmp;\n")
		do codes.add("tmp = heap[del_idx * 2];\n")
		do codes.add("heap[del_idx * 2] = heap[((del_idx + 1) * 2 - 1) * 2];\n")
		do codes.add("heap[((del_idx + 1) * 2 - 1) * 2] = tmp;\n")
		do codes.add("tmp = heap[del_idx * 2 + 1];\n")
		do codes.add("heap[del_idx * 2 + 1] = heap[((del_idx + 1) * 2 - 1) * 2 + 1];\n")
		do codes.add("heap[((del_idx + 1) * 2 - 1) * 2 + 1] = tmp;\n")
		do codes.add("del_idx = (del_idx + 1) * 2 - 1;\n")
		do codes.add("}\n")
		do codes.add("else if ((del_idx + 1) * 2 < heap_cnt && heap[del_idx * 2 + 1] > heap[((del_idx + 1) * 2) * 2 + 1])\n")
		do codes.add("{\n")
		do codes.add("int64_t tmp;\n")
		do codes.add("tmp = heap[del_idx * 2];\n")
		do codes.add("heap[del_idx * 2] = heap[((del_idx + 1) * 2) * 2];\n")
		do codes.add("heap[((del_idx + 1) * 2) * 2] = tmp;\n")
		do codes.add("tmp = heap[del_idx * 2 + 1];\n")
		do codes.add("heap[del_idx * 2 + 1] = heap[((del_idx + 1) * 2) * 2 + 1];\n")
		do codes.add("heap[((del_idx + 1) * 2) * 2 + 1] = tmp;\n")
		do codes.add("del_idx = (del_idx + 1) * 2;\n")
		do codes.add("}\n")
		do codes.add("else\n")
		do codes.add("break;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (distance[item_node] < item_value)\n")
		do codes.add("continue;\n")
		do codes.add("for (i = 0; i < len; i++)\n")
		do codes.add("{\n")
		do codes.add("if (from_nodes2[i] != item_node)\n")
		do codes.add("continue;\n")
		do codes.add("if (distance[to_nodes2[i]] > distance[item_node] + values2[i])\n")
		do codes.add("{\n")
		do codes.add("distance[to_nodes2[i]] = distance[item_node] + values2[i];\n")
		do codes.add("heap[heap_cnt * 2] = to_nodes2[i];\n")
		do codes.add("heap[heap_cnt * 2 + 1] = distance[to_nodes2[i]];\n")
		do codes.add("{\n")
		do codes.add("int64_t ins_idx = heap_cnt;\n")
		do codes.add("for (; ; )\n")
		do codes.add("{\n")
		do codes.add("if (ins_idx > 0 && heap[ins_idx * 2 + 1] < heap[(ins_idx - 1) / 2 * 2 + 1])\n")
		do codes.add("{\n")
		do codes.add("int64_t tmp;\n")
		do codes.add("tmp = heap[ins_idx * 2];\n")
		do codes.add("heap[ins_idx * 2] = heap[(ins_idx - 1) / 2 * 2];\n")
		do codes.add("heap[(ins_idx - 1) / 2 * 2] = tmp;\n")
		do codes.add("tmp = heap[ins_idx * 2 + 1];\n")
		do codes.add("heap[ins_idx * 2 + 1] = heap[(ins_idx - 1) / 2 * 2 + 1];\n")
		do codes.add("heap[(ins_idx - 1) / 2 * 2 + 1] = tmp;\n")
		do codes.add("ins_idx = (ins_idx - 1) / 2;\n")
		do codes.add("}\n")
		do codes.add("else\n")
		do codes.add("break;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("heap_cnt++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("free(heap);\n")
		do codes.add("\n")
		do codes.add("return result;\n")
	case "math_bellmanFord"
		do args.head()
		var from_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var to_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var values_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var begin_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(*(int64_t*)((U8*)from_nodes + 0x08) != *(int64_t*)((U8*)to_nodes + 0x08) || *(int64_t*)((U8*)to_nodes + 0x08) != *(int64_t*)((U8*)values + 0x08), EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("//THROWDBG(node_num <= 0 || begin_node < 0 || node_num <= begin_node, EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("const int64_t* from_nodes2 = \{from_nodes_.id}->B;\n")
		do codes.add("const int64_t* to_nodes2 = \{to_nodes_.id}->B;\n")
		do codes.add("const int64_t* values2 = \{values_.id}->B;\n")
		do codes.add("int64_t len = \{from_nodes_.id}->L;\n")
		do codes.add("int64_t i;\n")
		do codes.add("//for (i = 0; i < len; i++)\n")
		do codes.add("//\tTHROWDBG(from_nodes2[i] < 0 || node_num <= from_nodes2[i] || to_nodes2[i] < 0 || node_num <= to_nodes2[i], EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("\n")
		do codes.add("Array_<int64_t> *result=new Array_<int64_t>();\n")
		do codes.add("result->L = node_num;\n")
		do codes.add("result->B = new int64_t[node_num+1];\n")
		do codes.add("int64_t* distance = result->B;\n")
		do codes.add("for (i = 0; i < node_num; i++)\n")
		do codes.add("distance[i] = LLONG_MAX;\n")
		do codes.add("distance[begin_node] = 0;\n")
		do codes.add("\n")
		do codes.add("Bool found;\n")
		do codes.add("do\n")
		do codes.add("{\n")
		do codes.add("found = False;\n")
		do codes.add("for (i = 0; i < len; i++)\n")
		do codes.add("{\n")
		do codes.add("int64_t from_distance = distance[from_nodes2[i]];\n")
		do codes.add("if (from_distance != LLONG_MAX && distance[to_nodes2[i]] > from_distance + values2[i])\n")
		do codes.add("{\n")
		do codes.add("distance[to_nodes2[i]] = from_distance + values2[i];\n")
		do codes.add("found = True;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("} while (found);\n")
		do codes.add("return result;\n")
	case "file_copyFile"
		do args.head()
		var dst: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var src: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return copyFile_(\{dst.id}->B, \{src.id}->B);\n")
	case "file_exist"
		do args.head()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		; TODO:
		do codes.add("return false;\n")
	case "file_forEach"
		do args.head()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var recursion: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var callback: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var data: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		; TODO:
		do codes.add("return false;\n")
	case "file_makeReader"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("\{me_.id}->\{handle.id} = reinterpret_cast<int64_t>(new reader_());\n")
		do codes.add("std::u16string s_ = \{path.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\n")
		do codes.add("if(!*r_->F) return nullptr;\n")
		do codes.add("return \{me_.id};\n")
	case "file_makeWriter"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var append: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("\{me_.id}->\{handle.id} = reinterpret_cast<int64_t>(new writer_());\n")
		do codes.add("std::u16string s_ = \{path.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | (\{append.id} ? std::ios::app : std::ios::trunc));\n")
		do codes.add("if(!*r_->F) return nullptr;\n")
		do codes.add("return \{me_.id};\n")
	case "file_readerFin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->close();\n")
	case "file_readerGetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return static_cast<int64_t>(r_->F->tellg());\n")
	case "file_readerReadLetter"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("char16_t c_ = readUtf8_(r_->F);\n")
		;do codes.add("if (c_ == 0xffff)\n")
		;do codes.add("throw \{excpt@invalidDataFmt $ bit32}U;\n")
		do codes.add("return c_;\n")
	case "file_readerSetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var origin: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var pos: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("std::ios_base::seekdir o_ = std::ios_base::beg;\n")
		do codes.add("switch(\{origin.id}){\n")
		do codes.add("case 0: o_ = std::ios_base::beg; break;\n")
		do codes.add("case 1: o_ = std::ios_base::cur; break;\n")
		do codes.add("case 2: o_ = std::ios_base::end; break;\n")
		do codes.add("}\n")
		do codes.add("r_->F->seekg(\{pos.id}, o_);\n")
	case "file_readerTerm"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("char c_;\n")
		do codes.add("if(r_->F->get(c_)) {\n")
		do codes.add("r_->F->seekg(-1, std::ios_base::cur);\n")
		do codes.add("return false;\n")
		do codes.add("}\n")
		do codes.add("return true;\n")
	case "file_writerFin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->close();\n")
	case "file_writerGetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return static_cast<int64_t>(r_->F->tellp());\n")
	case "file_writerSetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var origin: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var pos: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("std::ios_base::seekdir o_ = std::ios_base::beg;\n")
		do codes.add("switch(\{origin.id}){\n")
		do codes.add("case 0: o_ = std::ios_base::beg; break;\n")
		do codes.add("case 1: o_ = std::ios_base::cur; break;\n")
		do codes.add("case 2: o_ = std::ios_base::end; break;\n")
		do codes.add("}\n")
		do codes.add("r_->F->seekp(\{pos.id}, o_);\n")
	case "file_writerWrite"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->write(reinterpret_cast<char*>(\{n.id}->B), \{n.id}->L);\n")
	case "file_writerWriteChar"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("writeUtf8_(r_->F, \{n.id});\n")
	case "exit_code"
		do args.head()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("exit_code_ = \{n.id};\n")
	case "wnd_editBaseGetText"
		; TODO:
	case "wnd_makeEditMulti"
		; TODO:
	default
		assert false
	end switch
	
	func search(members: list<\ast@AstClassItem>, name: []char): \cpp\output@CppInfo
		do members.head()
		while(!members.term())
			var def: \ast@Ast :: members.get().def
			if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
				ret \cpp\output@getInfo((def $ \ast@AstVar).arg)
			end if
			do members.next()
		end while
		assert false
		ret null
	end func
end func
