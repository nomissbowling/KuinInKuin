+func write(codes: list<[]char>, attr: []char, args: list<\ast@AstArg>, members: list<\ast@AstClassItem>)
	switch(attr)
	case "acos"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::acos(\{x.id});\n")
	case "acosh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::acosh(\{x.id});\n")
	case "addr"
		do args.head()
		var class_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return reinterpret_cast<uint64_t>(\{class_.id});\n")
	case "addDict"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->Add(\{key.id}, \{item.id});\n")
	case "addList"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push_back(\{item.id});\n")
	case "addQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push(\{item.id});\n")
	case "addStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push(\{item.id});\n")
	case "and"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} & \{n.id};\n")
	case "asin"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::asin(\{x.id});\n")
	case "asinh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::asinh(\{x.id});\n")
	case "atan"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::atan(\{x.id});\n")
	case "atanh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::atanh(\{x.id});\n")
	case "ceil"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::ceil(\{x.id});\n")
	case "cmdLine"
		do codes.add("Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\n")
		do codes.add("a_->L = argc_;\n")
		do codes.add("a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\n")
		do codes.add("for (int64_t i_ = 0; i_ < argc_; i_++){\n")
		do codes.add("std::string s_ = argv_[i_];\n")
		do codes.add("const std::u16string t_ = utf8ToUtf16_(s_);\n")
		do codes.add("a_->B[i_] = new Array_<char16_t>();\n")
		do codes.add("a_->B[i_]->L = static_cast<int64_t>(t_.size());\n")
		do codes.add("a_->B[i_]->B = new char16_t[t_.size() + 1];\n")
		do codes.add("std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\n")
		do codes.add("}\n")
		do codes.add("return a_;\n")
	case "cos"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::cos(\{x.id});\n")
	case "cosh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::cosh(\{x.id});\n")
	case "del"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("auto i_ = \{me_.id}->I++;\n")
		do codes.add("\{me_.id}->B.erase(i_);\n")
	case "dist"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var y: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerX: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerY: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::hypot(\{x.id} - \{centerX.id}, \{y.id} - \{centerY.id});\n")
	case "endian"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return endian_(\{me_.id});\n")
	case "exist"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictExist_(\{me_.id}->B, \{key.id});\n")
	case "exitCode"
		do args.head()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("exitCode_ = \{n.id};\n")
	case "exp"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::exp(\{x.id});\n")
	case "fill"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var value: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("for(int64_t i_ = 0; i_ < \{me_.id}->L; i_++) \{me_.id}->B[i_] = \{value.id};\n")
	case "findArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{start.id} == -1) \{start.id} = 0;\n")
		do codes.add("if(\{start.id} < 0) return -1;\n")
		do codes.add("for(int64_t i_ = \{start.id}; i_ < \{me_.id}->L; i_++){\n")
		do codes.add("if(\{me_.id}->B[i_] == \{item.id}) return i_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "findBin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("int64_t a_ = 0, b_ = \{me_.id}->L - 1;\n")
		do codes.add("while (a_ <= b_) {\n")
		do codes.add("int64_t c_ = (a_ + b_) / 2;\n")
		do codes.add("int64_t m_ = cmp_(\{item.id}, \{me_.id}->B[c_]);\n")
		do codes.add("if(m_ < 0) b_ = c_ - 1;\n")
		do codes.add("else if(m_ > 0) a_ = c_ + 1;\n")
		do codes.add("else return c_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "findLastArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{start.id} == -1) \{start.id} = \{me_.id}->L - 1;\n")
		do codes.add("if(\{start.id} >= \{me_.id}->L) return -1;\n")
		do codes.add("for(int64_t i_ = \{start.id}; i_ >= 0; i_--){\n")
		do codes.add("if(\{me_.id}->B[i_] == \{item.id}) return i_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "floor"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::floor(\{x.id});\n")
	case "forEach"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var callback: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var data: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictForEach_(\{me_.id}->B, reinterpret_cast<bool(*)(K_, V_, Class_*)>(\{callback.id}), \{data.id});\n")
	case "getDict"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var existed: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictSearch_(\{me_.id}->B, \{key.id}, \{existed.id});\n")
	case "getList"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return *\{me_.id}->I;\n")
	case "getQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("R_ r_ = \{me_.id}->B.front();\n")
		do codes.add("\{me_.id}->B.pop();\n")
		do codes.add("return r_;\n")
	case "getStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("R_ r_ = \{me_.id}->B.top();\n")
		do codes.add("\{me_.id}->B.pop();\n")
		do codes.add("return r_;\n")
	case "head"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->I = \{me_.id}->B.begin();\n")
	case "idx"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("int64_t i_ = 0;\n")
		do codes.add("for(auto t_ = \{me_.id}->B.begin(); t_ != \{me_.id}->B.end(); ++t_){\n")
		do codes.add("if(t_ == \{me_.id}->I) return i_;\n")
		do codes.add("i_++;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "ins"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.insert(\{me_.id}->I, \{item.id});\n")
	case "invRot"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var y: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerX: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var centerY: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("double r_ = std::atan2(\{y.id} - \{centerY.id}, \{x.id} - \{centerX.id});\n")
		do codes.add("return r_ < 0.0 ? r_ + 2.0 * 3.14159265358979323846 : r_;\n")
	case "ln"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::log(\{x.id});\n")
	case "max"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return max_(\{me_.id});")
	case "min"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return min_(\{me_.id});")
	case "moveOffset"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var offset: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{offset.id} >= 0){\n")
		do codes.add("for(int64_t i_ = 0; i_ < \{offset.id}; i_++){\n")
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.end()) break;\n")
		do codes.add("++\{me_.id}->I;\n")
		do codes.add("}\n")
		do codes.add("}else{\n")
		do codes.add("for(int64_t i_ = 0; i_ > \{offset.id}; i_--){\n")
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.end()) break;\n")
		do codes.add("--\{me_.id}->I;\n")
		do codes.add("}\n")
		do codes.add("}\n")
	case "next"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("++\{me_.id}->I;\n")
	case "not"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return ~\{me_.id};\n")
	case "now"
		do codes.add("return std::time(nullptr);\n")
	case "or"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} | \{n.id};\n")
	case "peekQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->B.front();\n")
	case "peekStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->B.top();\n")
	case "prev"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.begin())\n")
		do codes.add("\{me_.id}->I = \{me_.id}->B.end();\n")
		do codes.add("else\n")
		do codes.add("--\{me_.id}->I;\n")
	case "repeat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var len_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return repeat_(\{me_.id}, \{len_.id});\n")
	case "reverse"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("reverse_(\{me_.id});\n")
	case "rnd"
		do args.head()
		var min: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var max: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return rnd_(\{min.id}, \{max.id});\n")
	case "rndFloat"
		do args.head()
		var min: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var max: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return rndFloat_(\{min.id}, \{max.id});\n")
	case "sar"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		; TODO: sign
		do codes.add("return sar_(\{me_.id}, \{n.id});\n")
	case "shl"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} << \{n.id};\n")
	case "shr"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} >> \{n.id};\n")
	case "sin"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::sin(\{x.id});\n")
	case "sinh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::sinh(\{x.id});\n")
	case "sortArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("sort_(\{me_.id});\n")
	case "sqrt"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::sqrt(\{x.id});\n")
	case "sub"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var len: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return sub_(\{me_.id}, \{start.id}, \{len.id});\n")
	case "sysTime"
		do codes.add("return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n")
	case "tail"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->I = \{me_.id}->B.end();\n")
		do codes.add("--\{me_.id}->I;\n")
	case "tan"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::tan(\{x.id});\n")
	case "tanh"
		do args.head()
		var x: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return std::tanh(\{x.id});\n")
	case "term"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->I == \{me_.id}->B.end();\n")
	case "toArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return toArray_<C_>(\{me_.id});")
	case "toBit64"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("uint64_t v_ = t_.size() > 2 && t_[0] == '0' && t_[1] == 'x' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toFloat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("double v_ = std::stod(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toInt"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("int64_t v_ = t_.size() > 2 && t_[0] == '0' && t_[1] == 'x' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toStr"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return toStr_(\{me_.id});\n")
	case "xor"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} ^ \{n.id};\n")
	case "cui_inputLetter"
		do codes.add("return static_cast<char16_t>(fgetwc(stdin));\n")
	case "cui_print"
		do args.head()
		var str: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{str.id} == nullptr){\n")
		do codes.add("std::cout << \"(null)\";\n")
		do codes.add("return;\n")
		do codes.add("}\n")
		do codes.add("std::u16string s_ = \{str.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("std::cout << t_ << std::flush;\n")
	case "file_copyFile"
		do args.head()
		var dst: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var src: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return copyFile_(\{dst.id}->B, \{src.id}->B);\n")
	case "file_exist"
		do args.head()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		; TODO:
		do codes.add("return false;\n")
	case "file_forEach"
		do args.head()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var recursion: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var callback: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var data: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		; TODO:
		do codes.add("return false;\n")
	case "file_makeReader"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("\{me_.id}->\{handle.id} = reinterpret_cast<int64_t>(new reader_());\n")
		do codes.add("std::u16string s_ = \{path.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\n")
		do codes.add("if(!*r_->F) return nullptr;\n")
		do codes.add("return \{me_.id};\n")
	case "file_makeWriter"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var append: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("\{me_.id}->\{handle.id} = reinterpret_cast<int64_t>(new writer_());\n")
		do codes.add("std::u16string s_ = \{path.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | (\{append.id} ? std::ios::app : std::ios::trunc));\n")
		do codes.add("if(!*r_->F) return nullptr;\n")
		do codes.add("return \{me_.id};\n")
	case "file_readerFin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->close();\n")
	case "file_readerGetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return static_cast<int64_t>(r_->F->tellg());\n")
	case "file_readerReadLetter"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return readUtf8_(r_->F);\n")
	case "file_readerSetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var origin: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var pos: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("std::ios_base::seekdir o_ = std::ios_base::beg;\n")
		do codes.add("switch(\{origin.id}){\n")
		do codes.add("case 0: o_ = std::ios_base::beg; break;\n")
		do codes.add("case 1: o_ = std::ios_base::cur; break;\n")
		do codes.add("case 2: o_ = std::ios_base::end; break;\n")
		do codes.add("}\n")
		do codes.add("r_->F->seekg(\{pos.id}, o_);\n")
	case "file_readerTerm"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("char c_;\n")
		do codes.add("if(r_->F->get(c_)) {\n")
		do codes.add("r_->F->seekg(-1, std::ios_base::cur);\n")
		do codes.add("return false;\n")
		do codes.add("}\n")
		do codes.add("return true;\n")
	case "file_writerFin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->close();\n")
	case "file_writerGetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return static_cast<int64_t>(r_->F->tellp());\n")
	case "file_writerSetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var origin: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var pos: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("std::ios_base::seekdir o_ = std::ios_base::beg;\n")
		do codes.add("switch(\{origin.id}){\n")
		do codes.add("case 0: o_ = std::ios_base::beg; break;\n")
		do codes.add("case 1: o_ = std::ios_base::cur; break;\n")
		do codes.add("case 2: o_ = std::ios_base::end; break;\n")
		do codes.add("}\n")
		do codes.add("r_->F->seekp(\{pos.id}, o_);\n")
	case "file_writerWrite"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->write(reinterpret_cast<char*>(\{n.id}->B), \{n.id}->L);\n")
	case "file_writerWriteChar"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("writeUtf8_(r_->F, \{n.id});\n")
	case "wnd_editBaseGetText"
		; TODO:
	case "wnd_makeEditMulti"
		; TODO:
	default
		assert false
	end switch
	
	func search(members: list<\ast@AstClassItem>, name: []char): \cpp\output@CppInfo
		do members.head()
		while(!members.term())
			var def: \ast@Ast :: members.get().def
			if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
				ret \cpp\output@getInfo((def $ \ast@AstVar).arg)
			end if
			do members.next()
		end while
		assert false
		ret null
	end func
end func
