+func write(codes: list<[]char>, attr: []char, args: list<\ast@AstArg>, members: list<\ast@AstClassItem>, gc: bool)
	switch(attr)
	case "exist"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictExist_(\{me_.id}->B, \{key.id});\n")
	case "max"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return max_(\{me_.id});")
	case "min"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return min_(\{me_.id});")
	case "repeat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var len_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return repeat_(\{me_.id}, \{len_.id});\n")
	case "cui_inputLetter"
		do codes.add("return static_cast<char16_t>(fgetwc(stdin));\n")
	case "toStrFmtInt"
		; TODO: Refactoring.
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var fmt_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(fmt == NULL, EXCPT_ACCESS_VIOLATION);\n")
		do codes.add("const char16_t* fmt2 = \{fmt_.id}->B;\n")
		do codes.add("int src_len = \{fmt_.id}->L;\n")
		do codes.add("wchar_t dst[33];\n")
		do codes.add("int dst_ptr = 0;\n")
		do codes.add("int src_ptr = 0;\n")
		do codes.add("\n")
		do codes.add("dst[dst_ptr] = L'%';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'+' || fmt2[src_ptr] == L' '))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'-' || fmt2[src_ptr] == L'0'))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && L'1' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("while (src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 4 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (!(src_ptr < src_len && (fmt2[src_ptr] == L'd' || fmt2[src_ptr] == L'x' || fmt2[src_ptr] == L'X' || fmt2[src_ptr] == L'u' || fmt2[src_ptr] == L'o')))\n")
		do codes.add("return NULL;\n")
		do codes.add("/* Windows 7 (or later) accepts ll (as well as I64).*/\n")
		do codes.add("dst[dst_ptr] = L'l';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = L'l';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = L'\\0';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("//assert(src_ptr + 1 == src_len);\n")
		do codes.add("\n")
		do codes.add("wchar_t str[65];\n")
		do codes.add("int len = swprintf(str, 65, dst, \{me_.id});\n")
		do codes.add("//assert(len < 65);\n")
		do codes.add("type_(Array_<char16_t>) result = new_(Array_<char16_t>)();\n")
		do codes.add("result->B = newPrimArray_(len+1, char16_t);\n")
		do codes.add("for(int i=0;i<len;i++)result->B[i]=str[i];\n")
		do codes.add("result->B[len]=0;\n")
		do codes.add("result->L=len;\n")
		do codes.add("return result;\n")
	case "toStrFmtFloat"
		; TODO: Refactoring.
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var fmt_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(fmt == NULL, EXCPT_ACCESS_VIOLATION);\n")
		do codes.add("const char16_t* fmt2 = \{fmt_.id}->B;\n")
		do codes.add("int src_len = \{fmt_.id}->L;\n")
		do codes.add("wchar_t dst[33];\n")
		do codes.add("int dst_ptr = 0;\n")
		do codes.add("int src_ptr = 0;\n")
		do codes.add("\n")
		do codes.add("dst[dst_ptr] = L'%';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'+' || fmt2[src_ptr] == L' '))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && (fmt2[src_ptr] == L'-' || fmt2[src_ptr] == L'0'))\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && L'1' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("while (src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (src_ptr < src_len && fmt2[src_ptr] == L'.')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("if (!(src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9'))\n")
		do codes.add("return NULL;\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("while (src_ptr < src_len && L'0' <= fmt2[src_ptr] && fmt2[src_ptr] <= L'9')\n")
		do codes.add("{\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("if (dst_ptr + 1 >= 33)\n")
		do codes.add("return NULL;\n")
		do codes.add("src_ptr++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (!(src_ptr < src_len && (fmt2[src_ptr] == L'f' || fmt2[src_ptr] == L'e' || fmt2[src_ptr] == L'E' || fmt2[src_ptr] == L'g' || fmt2[src_ptr] == L'G' || fmt2[src_ptr] == L'a' || fmt2[src_ptr] == L'A')))\n")
		do codes.add("return NULL;\n")
		do codes.add("dst[dst_ptr] = fmt2[src_ptr];\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("dst[dst_ptr] = L'\\0';\n")
		do codes.add("dst_ptr++;\n")
		do codes.add("//assert(src_ptr + 1 == src_len);\n")
		do codes.add("\n")
		do codes.add("wchar_t str[65];\n")
		do codes.add("int len = swprintf(str, 65, dst, \{me_.id});\n")
		do codes.add("//assert(len < 65);\n")
		do codes.add("type_(Array_<char16_t>) result = new_(Array_<char16_t>)();\n")
		do codes.add("result->B = newPrimArray_(len+1, char16_t);\n")
		do codes.add("for(int i=0;i<len;i++)result->B[i]=str[i];\n")
		do codes.add("result->B[len]=0;\n")
		do codes.add("result->L=len;\n")
	case "math_gamma"
		; TODO: Refactoring.
		do args.head()
		var n_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return tgamma(\{n_.id});\n")
	case "math_dijkstra"
		; TODO: Refactoring.
		do args.head()
		var from_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var to_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var values_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var begin_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(*(int64_t*)((U8*)from_nodes + 0x08) != *(int64_t*)((U8*)to_nodes + 0x08) || *(int64_t*)((U8*)to_nodes + 0x08) != *(int64_t*)((U8*)values + 0x08), EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("//THROWDBG(node_num <= 0 || begin_node < 0 || node_num <= begin_node, EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("const int64_t* from_nodes2 = \{from_nodes_.id}->B;\n")
		do codes.add("const int64_t* to_nodes2 = \{to_nodes_.id}->B;\n")
		do codes.add("const int64_t* values2 = \{values_.id}->B;\n")
		do codes.add("int64_t len = \{from_nodes_.id}->L;\n")
		do codes.add("int64_t i;\n")
		do codes.add("//for (i = 0; i < len; i++)\n")
		do codes.add("//\tTHROWDBG(from_nodes2[i] < 0 || node_num <= from_nodes2[i] || to_nodes2[i] < 0 || node_num <= to_nodes2[i] || values2[i] < 0, EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("\n")
		do codes.add("type_(Array_<int64_t>) result=new_(Array_<int64_t>)();\n")
		do codes.add("result->L = node_num;\n")
		do codes.add("result->B = newPrimArray_(node_num+1, int64_t);\n")
		do codes.add("int64_t* distance = result->B;\n")
		do codes.add("for (i = 0; i < node_num; i++)\n")
		do codes.add("distance[i] = LLONG_MAX;\n")
		do codes.add("distance[\{begin_nodes_.id}] = 0;\n")
		do codes.add("\n")
		do codes.add("int64_t* heap = (int64_t*)malloc(sizeof(int64_t) * (2 * (size_t)(node_num * len) + 2));\n")
		do codes.add("int heap_cnt = 1;\n")
		do codes.add("heap[0] = begin_node;\n")
		do codes.add("heap[1] = 0;\n")
		do codes.add("while (heap_cnt > 0)\n")
		do codes.add("{\n")
		do codes.add("int64_t item_node = heap[0];\n")
		do codes.add("int64_t item_value = heap[1];\n")
		do codes.add("heap_cnt--;\n")
		do codes.add("heap[0] = heap[heap_cnt * 2];\n")
		do codes.add("heap[1] = heap[heap_cnt * 2 + 1];\n")
		do codes.add("{\n")
		do codes.add("int64_t del_idx = 0;\n")
		do codes.add("for (; ; )\n")
		do codes.add("{\n")
		do codes.add("if ((del_idx + 1) * 2 - 1 < heap_cnt && heap[del_idx * 2 + 1] > heap[((del_idx + 1) * 2 - 1) * 2 + 1])\n")
		do codes.add("{\n")
		do codes.add("int64_t tmp;\n")
		do codes.add("tmp = heap[del_idx * 2];\n")
		do codes.add("heap[del_idx * 2] = heap[((del_idx + 1) * 2 - 1) * 2];\n")
		do codes.add("heap[((del_idx + 1) * 2 - 1) * 2] = tmp;\n")
		do codes.add("tmp = heap[del_idx * 2 + 1];\n")
		do codes.add("heap[del_idx * 2 + 1] = heap[((del_idx + 1) * 2 - 1) * 2 + 1];\n")
		do codes.add("heap[((del_idx + 1) * 2 - 1) * 2 + 1] = tmp;\n")
		do codes.add("del_idx = (del_idx + 1) * 2 - 1;\n")
		do codes.add("}\n")
		do codes.add("else if ((del_idx + 1) * 2 < heap_cnt && heap[del_idx * 2 + 1] > heap[((del_idx + 1) * 2) * 2 + 1])\n")
		do codes.add("{\n")
		do codes.add("int64_t tmp;\n")
		do codes.add("tmp = heap[del_idx * 2];\n")
		do codes.add("heap[del_idx * 2] = heap[((del_idx + 1) * 2) * 2];\n")
		do codes.add("heap[((del_idx + 1) * 2) * 2] = tmp;\n")
		do codes.add("tmp = heap[del_idx * 2 + 1];\n")
		do codes.add("heap[del_idx * 2 + 1] = heap[((del_idx + 1) * 2) * 2 + 1];\n")
		do codes.add("heap[((del_idx + 1) * 2) * 2 + 1] = tmp;\n")
		do codes.add("del_idx = (del_idx + 1) * 2;\n")
		do codes.add("}\n")
		do codes.add("else\n")
		do codes.add("break;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("if (distance[item_node] < item_value)\n")
		do codes.add("continue;\n")
		do codes.add("for (i = 0; i < len; i++)\n")
		do codes.add("{\n")
		do codes.add("if (from_nodes2[i] != item_node)\n")
		do codes.add("continue;\n")
		do codes.add("if (distance[to_nodes2[i]] > distance[item_node] + values2[i])\n")
		do codes.add("{\n")
		do codes.add("distance[to_nodes2[i]] = distance[item_node] + values2[i];\n")
		do codes.add("heap[heap_cnt * 2] = to_nodes2[i];\n")
		do codes.add("heap[heap_cnt * 2 + 1] = distance[to_nodes2[i]];\n")
		do codes.add("{\n")
		do codes.add("int64_t ins_idx = heap_cnt;\n")
		do codes.add("for (; ; )\n")
		do codes.add("{\n")
		do codes.add("if (ins_idx > 0 && heap[ins_idx * 2 + 1] < heap[(ins_idx - 1) / 2 * 2 + 1])\n")
		do codes.add("{\n")
		do codes.add("int64_t tmp;\n")
		do codes.add("tmp = heap[ins_idx * 2];\n")
		do codes.add("heap[ins_idx * 2] = heap[(ins_idx - 1) / 2 * 2];\n")
		do codes.add("heap[(ins_idx - 1) / 2 * 2] = tmp;\n")
		do codes.add("tmp = heap[ins_idx * 2 + 1];\n")
		do codes.add("heap[ins_idx * 2 + 1] = heap[(ins_idx - 1) / 2 * 2 + 1];\n")
		do codes.add("heap[(ins_idx - 1) / 2 * 2 + 1] = tmp;\n")
		do codes.add("ins_idx = (ins_idx - 1) / 2;\n")
		do codes.add("}\n")
		do codes.add("else\n")
		do codes.add("break;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("heap_cnt++;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("free(heap);\n")
		do codes.add("\n")
		do codes.add("return result;\n")
	case "math_bellmanFord"
		; TODO: Refactoring.
		do args.head()
		var from_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var to_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var values_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var begin_nodes_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("//THROWDBG(*(int64_t*)((U8*)from_nodes + 0x08) != *(int64_t*)((U8*)to_nodes + 0x08) || *(int64_t*)((U8*)to_nodes + 0x08) != *(int64_t*)((U8*)values + 0x08), EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("//THROWDBG(node_num <= 0 || begin_node < 0 || node_num <= begin_node, EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("const int64_t* from_nodes2 = \{from_nodes_.id}->B;\n")
		do codes.add("const int64_t* to_nodes2 = \{to_nodes_.id}->B;\n")
		do codes.add("const int64_t* values2 = \{values_.id}->B;\n")
		do codes.add("int64_t len = \{from_nodes_.id}->L;\n")
		do codes.add("int64_t i;\n")
		do codes.add("//for (i = 0; i < len; i++)\n")
		do codes.add("//\tTHROWDBG(from_nodes2[i] < 0 || node_num <= from_nodes2[i] || to_nodes2[i] < 0 || node_num <= to_nodes2[i], EXCPT_DBG_ARG_OUT_DOMAIN);\n")
		do codes.add("\n")
		do codes.add("type_(Array_<int64_t>) result=new_(Array_<int64_t>)();\n")
		do codes.add("result->L = node_num;\n")
		do codes.add("result->B = newPrimArray_(node_num+1, int64_t);\n")
		do codes.add("int64_t* distance = result->B;\n")
		do codes.add("for (i = 0; i < node_num; i++)\n")
		do codes.add("distance[i] = LLONG_MAX;\n")
		do codes.add("distance[begin_node] = 0;\n")
		do codes.add("\n")
		do codes.add("Bool found;\n")
		do codes.add("do\n")
		do codes.add("{\n")
		do codes.add("found = False;\n")
		do codes.add("for (i = 0; i < len; i++)\n")
		do codes.add("{\n")
		do codes.add("int64_t from_distance = distance[from_nodes2[i]];\n")
		do codes.add("if (from_distance != LLONG_MAX && distance[to_nodes2[i]] > from_distance + values2[i])\n")
		do codes.add("{\n")
		do codes.add("distance[to_nodes2[i]] = from_distance + values2[i];\n")
		do codes.add("found = True;\n")
		do codes.add("}\n")
		do codes.add("}\n")
		do codes.add("} while (found);\n")
		do codes.add("return result;\n")
	case "file_copyFile"
		do args.head()
		var dst: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var src: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return copyFile_(\{dst.id}->B, \{src.id}->B);\n")
	case "wnd_editBaseGetText"
		; TODO:
	case "wnd_makeEditMulti"
		; TODO:
	default
		assert false
	end switch
	
	func search(members: list<\ast@AstClassItem>, name: []char): \cpp\output@CppInfo
		do members.head()
		while(!members.term())
			var def: \ast@Ast :: members.get().def
			if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
				ret \cpp\output@getInfo((def $ \ast@AstVar).arg)
			end if
			do members.next()
		end while
		assert false
		ret null
	end func
end func
