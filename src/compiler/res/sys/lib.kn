+const pi: float :: 3.14159265358979323846
+const e: float :: 2.71828182845904523536
+const intMin: int :: -9223372036854775807 - 1
+const intMax: int :: 9223372036854775807

var globalRnd: @Rnd

func _init()
	do @globalRnd :: #@Rnd
	do @globalRnd.setSeed((@sysTime() $ bit32).xor(@now() $ bit32))
end func

+func cmdLine(): [][]char
	if(env = "cpp")
		excode "auto a_=new_(Array_<type_(Array_<char16_t>)>)();\n"
		excode "a_->L=argc_;\n"
		excode "a_->B=newPrimArray_(static_cast<size_t>(argc_),type_(Array_<char16_t>));\n"
		excode "for(int64_t i_=0;i_<argc_;i_++){\n"
		excode "std::string s_=argv_[i_];\n"
		excode "const std::u16string t_=utf8ToUtf16_(s_);\n"
		excode "a_->B[i_]=new_(Array_<char16_t>)();\n"
		excode "a_->B[i_]->L=static_cast<int64_t>(t_.size());\n"
		excode "a_->B[i_]->B=newPrimArray_(t_.size()+1,char16_t);\n"
		excode "std::memcpy(a_->B[i_]->B,t_.c_str(),sizeof(char16_t)*(t_.size()+1));\n"
		excode "}\n"
		excode "return a_;\n"
	elif(env = "web")
		excode "let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\"&\");\n"
		excode "if(r_.length==1&&r_[0]==\"\")return[];\n"
		excode "for(let i_=0;i_<r_.length;i_++)\n"
		excode "r_[i_]={S:r_[i_]};\n"
		excode "return r_;\n"
	end if
end func

+func exitCode(code: int)
	if(dbg)
		if(code < 0 | 0xFFFFFFFF < code)
			throw excpt@dbgArgOutDomain
		end if
	end if
	if(env = "cpp")
		excode "exitCode_=`0`;\n"
	elif(env = "web")
	end if
end func

+class Rnd()
	+func setSeed(seed: bit32)
		do me.x :: 123456789b32
		do me.y :: 362436069b32
		do me.z :: 521288629b32 * seed
		do me.w :: 88675123b32 * me.z.shr(1)
	end func
	
	+func rnd(min: int, max: int): int
		if(dbg)
			if(min > max)
				throw excpt@dbgArgOutDomain
			end if
		end if
		var n: bit64 :: (max - min + 1) $ bit64
		var m: bit64 :: 0b64 - ((0b64 - n) % n)
		var r: bit64
		if(m = 0b64)
			do r :: (me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64)
		else
			while(m <= r, skip)
				do r :: (me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64)
			end while
		end if
		ret(r % n) $ int + min
	end func
	
	+func rndFloat(min: float, max: float): float
		if(dbg)
			if(min > max)
				throw excpt@dbgArgOutDomain
			end if
		end if
		ret(me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64) $ float / 18446744073709551616.0 * (max - min) + min
	end func
	
	+func rndBit64(): bit64
		ret(me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64)
	end func
	
	func xs128(): bit32
		var t: bit32 :: me.x.xor(me.x.shl(11))
		do me.x :: me.y
		do me.y :: me.z
		do me.z :: me.w
		do me.w :: me.w.xor(me.w.shr(19)).xor(t.xor(t.shr(8)))
		ret me.w
	end func
	
	var x: bit32
	var y: bit32
	var z: bit32
	var w: bit32
end class

+func makeRnd(seed: bit32): @Rnd
	var r: @Rnd :: #@Rnd
	do r.setSeed(seed)
	ret r
end func

+func rnd(min: int, max: int): int
	ret @globalRnd.rnd(min, max)
end func

+func rndFloat(min: float, max: float): float
	ret @globalRnd.rndFloat(min, max)
end func

+func rndBit64(): bit64
	ret @globalRnd.rndBit64()
end func

+func[d0000.knd, _rndUuid]rndUuid(): []char
	; TODO:
end func

+func cos(x: float): float
	if(env = "cpp")
		excode "return std::cos(`0`);\n"
	elif(env = "web")
		excode "return Math.cos(`0`);\n"
	end if
end func

+func sin(x: float): float
	if(env = "cpp")
		excode "return std::sin(`0`);\n"
	elif(env = "web")
		excode "return Math.sin(`0`);\n"
	end if
end func

+func tan(x: float): float
	if(env = "cpp")
		excode "return std::tan(`0`);\n"
	elif(env = "web")
		excode "return Math.tan(`0`);\n"
	end if
end func

+func acos(x: float): float
	if(env = "cpp")
		excode "return std::acos(`0`);\n"
	elif(env = "web")
		excode "return Math.acos(`0`);\n"
	end if
end func

+func asin(x: float): float
	if(env = "cpp")
		excode "return std::asin(`0`);\n"
	elif(env = "web")
		excode "return Math.asin(`0`);\n"
	end if
end func

+func atan(x: float): float
	if(env = "cpp")
		excode "return std::atan(`0`);\n"
	elif(env = "web")
		excode "return Math.atan(`0`);\n"
	end if
end func

+func cosh(x: float): float
	if(env = "cpp")
		excode "return std::cosh(`0`);\n"
	elif(env = "web")
		excode "return Math.cosh(`0`);\n"
	end if
end func

+func sinh(x: float): float
	if(env = "cpp")
		excode "return std::sinh(`0`);\n"
	elif(env = "web")
		excode "return Math.sinh(`0`);\n"
	end if
end func

+func tanh(x: float): float
	if(env = "cpp")
		excode "return std::tanh(`0`);\n"
	elif(env = "web")
		excode "return Math.tanh(`0`);\n"
	end if
end func

+func acosh(x: float): float
	if(env = "cpp")
		excode "return std::acosh(`0`);\n"
	elif(env = "web")
		excode "return Math.log(`0`+Math.sqrt(`0`*`0`-1));\n"
	end if
end func

+func asinh(x: float): float
	if(env = "cpp")
		excode "return std::asinh(`0`);\n"
	elif(env = "web")
		excode "return Math.log(`0`+Math.sqrt(`0`*`0`+1));\n"
	end if
end func

+func atanh(x: float): float
	if(env = "cpp")
		excode "return std::atanh(`0`);\n"
	elif(env = "web")
		excode "return 0.5*Math.log((1+`0`)/(1-`0`));\n"
	end if
end func

+func sqrt(x: float): float
	if(env = "cpp")
		excode "return std::sqrt(`0`);\n"
	elif(env = "web")
		excode "return Math.sqrt(`0`);\n"
	end if
end func

+func exp(x: float): float
	if(env = "cpp")
		excode "return std::exp(`0`);\n"
	elif(env = "web")
		excode "return Math.exp(`0`);\n"
	end if
end func

+func ln(x: float): float
	if(env = "cpp")
		excode "return std::log(`0`);\n"
	elif(env = "web")
		excode "return Math.log(`0`);\n"
	end if
end func

+func log(base: float, x: float): float
	ret @ln(x) / @ln(base)
end func

+func floor(x: float): float
	if(env = "cpp")
		excode "return std::floor(`0`);\n"
	elif(env = "web")
		excode "return Math.floor(`0`);\n"
	end if
end func

+func ceil(x: float): float
	if(env = "cpp")
		excode "return std::ceil(`0`);\n"
	elif(env = "web")
		excode "return Math.ceil(`0`);\n"
	end if
end func

+func round(x: float, precision: int): float
	if(precision = 0)
		ret x >= 0.0 ?(@floor(x + 0.5), -@floor(-x + 0.5))
	else
		var p: float :: 10.0 ^ (precision $ float)
		ret x >= 0.0 ?(@floor(x * p + 0.5) / p, -@floor(-x * p + 0.5) / p)
	end if
end func

+func rot(x: &float, y: &float, centerX: float, centerY: float, angle: float)
	var x2: float :: x - centerX
	var y2: float :: y - centerY
	var cosTheta: float :: @cos(angle)
	var sinTheta: float :: @sin(angle)
	var x3: float :: x2 * cosTheta - y2 * sinTheta
	var y3: float :: x2 * sinTheta + y2 * cosTheta
	do x :: x3 + centerX
	do y :: y3 + centerY
end func

+func invRot(x: float, y: float, centerX: float, centerY: float): float
	if(env = "cpp")
		excode "double r_=std::atan2(`1`-`3`,`0`-`2`);\n"
		excode "return r_< 0.0?r_+2.0*3.14159265358979323846:r_;\n"
	elif(env = "web")
		excode "let r_=Math.atan2(`1`-`3`,`0`-`2`);\n"
		excode "return r_<0.0?r_+2.0*Math.PI:r_;\n"
	end if
end func

+func dist(x: float, y: float, centerX: float, centerY: float): float
	if(env = "cpp")
		excode "return std::hypot(`0`-`2`,`1`-`3`);\n"
	elif(env = "web")
		excode "let x_=`0`-`2`,y_=`1`-`3`;\n"
		excode "return Math.sqrt(x_*x_+y_*y_);\n"
	end if
end func

+func chase(x: &float, target: float, vel: float): bool
	if(x = target)
		ret true
	end if
	if(x < target)
		do x :+ vel
		if(x >= target)
			do x :: target
			ret true
		end if
	else
		do x :- vel
		if(x <= target)
			do x :: target
			ret true
		end if
	end if
	ret false
end func

+func same(n1: float, n2: float): bool
	; TODO:
	var max: float :: 1.0
	if(max < n1)
		do max :: n1
	end if
	if(max < n2)
		do max :: n2
	end if
	ret(n1 - n2).abs() <= 2.220446049250313e-16 * max
end func

+func toRad(degree: float): float
	ret degree * @pi / 180.0
end func

+func toDegree(rad: float): float
	ret rad * 180.0 / @pi
end func

+func cmp(s1: []char, s2: []char): int
	var p: int :: 0
	while(p < ^s1 & p < ^s2)
		if(s1[p] <> s2[p])
			ret s1[p] > s2[p] ?(1, s1[p] < s2[p] ?(-1, 0))
		end if
		do p :+ 1
	end while
	ret ^ s1 > ^s2 ?(1, ^s1 < ^s2 ?(-1, 0))
end func

+func[d0000.knd, _cmpEx]cmpEx(s1: []char, s2: []char, len: int, ignoreCase: bool): int
end func

+func min(n1: int, n2: int): int
	ret n1 <= n2 ?(n1, n2)
end func

+func minFloat(n1: float, n2: float): float
	ret n1 <= n2 ?(n1, n2)
end func

+func max(n1: int, n2: int): int
	ret n1 >= n2 ?(n1, n2)
end func

+func maxFloat(n1: float, n2: float): float
	ret n1 >= n2 ?(n1, n2)
end func

+func[d0000.knd, _levenshtein]levenshtein(s1: []char, s2: []char): int
end func

+func[d0000.knd, _lerp]lerp(first: float, last: float, rate: float): float
end func

+func[d0000.knd, _qerp]qerp(first: float, last: float, easeIn: bool, rate: float): float
end func

+func[d0000.knd, _cerp]cerp(first: float, last: float, rate: float): float
end func

+func[d0000.knd, _hermite]hermite(pos: []float, rate: float): float
end func

+class BmSearch()
	*func[d0000.knd, _bmSearchDtor, __frc]_dtor()
	end func
	
	+func[d0000.knd, _bmSearchFind]find(text: []char, start: int): int
	end func
	
	var pattern: int
	var dists: int
	var len: int
end class

+func[d0000.knd, _makeBmSearch, __mki]makeBmSearch(me2: @BmSearch, pattern: []char): @BmSearch
end func

+func sysTime(): int
	if(env = "cpp")
		excode "return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n"
	elif(env = "web")
		excode "let n_=new Date().getTime();\n"
		excode "return Uint32Array.from([Math.floor(n_/0x100000000),n_%0x100000000]);\n"
	end if
end func

+func now(): int
	if(env = "cpp")
		excode "return std::time(nullptr);\n"
	elif(env = "web")
		excode "let n_=Math.floor(new Date().getTime()/1000);\n"
		excode "return Uint32Array.from([Math.floor(n_/0x100000000),n_%0x100000000]);\n"
	end if
end func

+func intToDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int
	var t: int :: time + 719468 * 86400
	var a: int :: t / 86400
	var b: int :: (a >= 0 ?(a, a - 146096)) / 146097
	var c: int :: a - b * 146097
	var d: int :: (c - c / 1460 + c / 36524 - c / 146096) / 365
	var e: int :: c - (365 * d + d / 4 - d / 100)
	var f: int :: (5 * e + 2) / 153
	do day :: e - (153 * f + 2) / 5 + 1
	do month :: f + (f < 10 ?(3, -9))
	do year :: d + b * 400 + (month <= 2 ?(1, 0))
	var s: int :: t % 86400
	do hour :: s / 3600
	do s :- hour * 3600
	do minute :: s / 60
	do second :: s - minute * 60
	var g: int :: a - 719468
	ret g >= -4 ?((g + 4) % 7, (g + 5) % 7 + 6)
end func

+func dateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int
	assert 1 <= month & month <= 12 & 1 <= day & day <= 31 & 0 <= hour & hour <= 23 & 0 <= minute & minute <= 59 & 0 <= second & second <= 59
	var a: int :: year - (month <= 2 ?(1, 0))
	var b: int :: (a >= 0 ?(a, a - 399)) / 400
	var c: int :: a - b * 400
	var d: int :: (153 * (month + (month > 2 ?(-3, 9))) + 2) / 5 + day - 1
	ret(b * 146097 + c * 365 + c / 4 - c / 100 + d - 719468) * 86400 + hour * 3600 + minute * 60 + second
end func

+func[d0000.knd, _intToLocalDate]intToLocalDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int
end func

+func[d0000.knd, _localDateToInt]localDateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int
end func

+func[d0000.knd]sleep(ms: int)
end func

+func[d0000.knd, _countUp]countUp(min: int, max: int): []int
end func

+func addr(class_: kuin@Class): bit64
	if(env = "cpp")
		excode "return addr_(`0`);\n"
	elif(env = "web")
		excode "return Uint32Array.from([0,`0`.A_]);\n"
	end if
end func

+class Int()
	+*func cmp(t: @Int): int
		ret(me.value - t.value).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: int
end class

+class Float()
	+*func cmp(t: @Float): int
		ret(me.value - t.value).sign() $ int
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: float
end class

+class Bool()
	+*func cmp(t: @Bool): int
		ret(me.value $ int - t.value $ int).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: bool
end class

+class Char()
	+*func cmp(t: @Char): int
		ret(me.value $ int - t.value $ int).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: char
end class

+class Str()
	+*func cmp(t: @Str): int
		ret @cmp(me.value, t.value)
	end func
	
	+*func toStr(): []char
		ret me.value
	end func
	
	+var value: []char
end class
