+func gcd(a: int, b: int): int
	if(a = 0)
		if(b = 0)
			throw excpt@dbgArgOutDomain
		end if
		ret b
	end if
	if(b = 0)
		ret a
	end if
	if(a < 0)
		do a :: -a
	end if
	if(b < 0)
		do b :: -b
	end if
	if(b > a)
		do a :$ b
	end if
	var r: int
	while loop(true)
		do r :: a % b
		if(r = 0)
			ret b
		end if
		do a :: b
		do b :: r
	end while
end func

+func lcm(a: int, b: int): int
	if(a = 0)
		if(b = 0)
			throw excpt@dbgArgOutDomain
		end if
		ret 0
	end if
	if(b = 0)
		ret 0
	end if
	if(a < 0)
		do a :: -a
	end if
	if(b < 0)
		do b :: -b
	end if
	ret a / @gcd(a, b) * b
end func

+func modPow(value: int, exponent: int, modulus: int): int
	if(value < 0 | exponent < 0 | modulus < 0)
		throw excpt@dbgArgOutDomain
	end if
	ret @modPowUnsigned(value $ bit64, exponent $ bit64, modulus $ bit64) $ int
end func

+func modMul(a: int, b: int, modulus: int): int
	if(a < 0 | b < 0 | modulus < 0)
		throw excpt@dbgArgOutDomain
	end if
	ret @modMulUnsigned(a $ bit64, b $ bit64, modulus $ bit64) $ int
end func

+func prime(n: int): bool
	if(n <= 1)
		ret false
	end if
	if(n % 2 = 0)
		ret n = 2
	end if
	if(n = 3)
		ret true
	end if
	{
	; cf https://github.com/kuina/KuinInKuin/issues/12
	if(n <= 1920000)
		if(n % 6 <> 1 & n % 6 <> 5)
			ret false
		end if
		var m: int :: n / 6 * 2 + (n % 6 = 1 ?(0,1))
		var primes_bin: []bit8 :: @getPrimesBin()
		ret primes_bin[m / 8].and(1b8.shl(m % 8)) <> (0 $ bit8)
	end if
}
	var thresh: int :: 1373653
	if(n <= thresh)
		if(!@sieveInit)
			do @sieveInit :: true
			do @sieve :: #[thresh + 1]bool
			do @sieve[0] :: false
			do @sieve[1] :: false
			for i(2, thresh)
				do @sieve[i] :: true
			end for
			var i: int :: 2
			while(i * i <= thresh)
				if(@sieve[i])
					var j: int :: i + i
					while(j <= thresh)
						do @sieve[j] :: false
						do j :+ i
					end while
				end if
				do i :+ 1
			end while
		end if
		ret @sieve[n]
	end if
	
	; Miller-Rabin primality test.
	var primes: []int :: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
	var enough: int :: 0
	if(n < 2047)
		do enough :: 1
	elif(n < 1373653)
		do enough :: 2
	elif(n < 25326001)
		do enough :: 3
	elif(n < 3215031751)
		do enough :: 4
	elif(n < 2152302898747)
		do enough :: 5
	elif(n < 3474749660383)
		do enough :: 6
	elif(n < 341550071728321)
		do enough :: 7
	elif(n < 3825123056546413051)
		do enough :: 9
	else
		; n < 2^64 < 318665857834031151167461
		do enough :: 12
	end if
	
	var d: int :: n - 1
	var s: int :: 0
	while(d % 2 = 0)
		do s :+ 1
		do d :/ 2
	end while
	for i(0, enough - 1)
		var x: int :: @modPow(primes[i], d, n)
		if(x = 1 | x = n - 1)
			skip i
		end if
		var probablyPrime: bool :: false
		for j(0, s - 1)
			do x :: @modPow(x, 2, n)
			if(x = n - 1)
				do probablyPrime :: true
				break j
			end if
		end for
		if(!probablyPrime)
			ret false
		end if
	end for
	ret true
end func

+func primeFactors(n: int): []int
	var result: []int :: #[0]int
	while loop(n > 1)
		var factor: int :: @findFactor(n)
		do result :~ [factor]
		do n :/ factor
	end while
	do result.sort()
	ret result
end func

+func[__raw, math_gamma]gamma(n: float): float
end func

+func fact(n: float): float
	ret @gamma(n + 1.0)
end func

+func factInt(n: int): int
	if(n < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(n > 20)
		throw excpt@dbgIntOverflow
	end if
	var result: int :: 1
	for i(1, n)
		do result :* i
	end for
	ret result
end func

+func fibonacci(n: int): int
	if(n < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(n > 92)
		throw excpt@dbgIntOverflow
	end if
	if(n = 0)
		ret 0
	end if
	var a: int :: 0
	var b: int :: 1
	for i(2, n)
		var t: int :: a + b
		do a :: b
		do b :: t
	end for
	ret b
end func

+func knapsack(weights: []int, values: []int, maxWeight: int, reuse: bool): int
	var dp: []int :: #[maxWeight + 1]int
	if(reuse)
		for i(0, ^weights - 1)
			var j: int :: weights[i]
			while(j <= maxWeight)
				var value: int :: dp[j - weights[i]] + values[i]
				if(dp[j] < value)
					do dp[j] :: value
				end if
				do j :+ 1
			end while
		end for
	else
		for i(0, ^weights - 1)
			var j: int :: maxWeight
			while(j >= weights[i])
				var value: int :: dp[j - weights[i]] + values[i]
				if(dp[j] < value)
					do dp[j] :: value
				end if
				do j :- 1
			end while
		end for
	end if
	ret dp[maxWeight]
end func

+func[__raw, math_dijkstra]dijkstra(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func[__raw, math_bellmanFord]bellmanFord(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func[d0003.knd, _floydWarshall]floydWarshall(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int): [][]int
end func

func[__raw, rndRaw]rndRaw(): int
end func

func findFactor(n: int): int
	; Pollard's rho algorithm.
	var n2: int :: n
	while(true)
		if(n2 % 2 = 0)
			ret 2
		end if
		if(@prime(n2))
			ret n2
		end if
		var a: int :: (@rndRaw() % 0x7FFFFFFF) * 0x100000000 + @rndRaw()
		var y: int :: a % (n2 + 1)
		var c: int :: @rndRaw() + 1
		var m: int :: @rndRaw() + 1
		var g: int :: 0 { dummy init }
		var r: int :: 1
		var q: int :: 1
		var ys: int :: 0
		var x: int :: 0 { dummy init }
		while(g <= 1)
			do x :: y
			for i(0, r - 1)
				do y :: (@modMul(y, y, n2) + c)%n2
			end for
			var k: int :: 0
			while(k < r & g <= 1)
				do ys :: y
				var min_value: int :: m < r - k ?(m, r - k)
				for i(0, min_value - 1)
					do y :: (@modMul(y, y, n2) + c)%n2
					do q :: @modMul(q, x > y ?(x - y, y - x), n2)
				end for
				do g :: @gcd(q, n2)
				do k :+ m
			end while
			do r :* 2
		end while
		
		if(g = n2)
			while(g <= 1)
				do ys :: (@modMul(ys, ys, n2) + c)%n2
				do g :: @gcd(x > ys ?(x - ys, ys - x), n2)
			end while
		end if
		if(g = n2)
			; next rndRaw will be performed using different state.
		else
			do n2 :: g
		end if
	end while
end func

var sieve: []bool
var sieveInit: bool :: false

func modPowUnsigned(value: bit64, exponent: bit64, modulus: bit64): bit64
	var w: bit64 :: 1b64
	while(exponent > 0b64)
		if(exponent.and(1b64) <> 0b64)
			do w :: modMulUnsigned(w, value, modulus)
		end if
		do value :: modMulUnsigned(value, value, modulus)
		do exponent :: exponent.shr(1)
	end while
	ret w
end func

func modMulUnsigned(a: bit64, b: bit64, modulus: bit64): bit64
	var w: bit64 :: 0
	while(a > 0b64)
		if(a.and(1b64) <> 0b64)
			do w :: (w + b) % modulus
		end if
		do b :: b.shl(1) % modulus
		do a :: a.shr(1)
	end while
	ret w
end func
