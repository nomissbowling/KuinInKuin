+func gcd(a: int, b: int): int
	if(a = 0)
		if(b = 0)
			throw excpt@dbgArgOutDomain
		end if
		ret b
	end if
	if(b = 0)
		ret a
	end if
	if(a < 0)
		do a :: -a
	end if
	if(b < 0)
		do b :: -b
	end if
	if(b > a)
		do a :$ b
	end if
	var r: int
	while loop(true)
		do r :: a % b
		if(r = 0)
			ret b
		end if
		do a :: b
		do b :: r
	end while
end func

+func lcm(a: int, b: int): int
	if(a = 0)
		if(b = 0)
			throw excpt@dbgArgOutDomain
		end if
		ret 0
	end if
	if(b = 0)
		ret 0
	end if
	if(a < 0)
		do a :: -a
	end if
	if(b < 0)
		do b :: -b
	end if
	ret a / @gcd(a, b) * b
end func

+func modPow(value: int, exponent: int, modulus: int): int
	if(value < 0 | exponent < 0 | modulus < 0)
		throw excpt@dbgArgOutDomain
	end if
	ret @modPowUnsigned(value $ bit64, exponent $ bit64, modulus $ bit64) $ int
end func

+func modMul(a: int, b: int, modulus: int): int
	if(a < 0 | b < 0 | modulus < 0)
		throw excpt@dbgArgOutDomain
	end if
	ret @modMulUnsigned(a $ bit64, b $ bit64, modulus $ bit64) $ int
end func

+func prime(n: int): bool
	if(n <= 1)
		ret false
	end if
	var n2: bit64 :: n $ bit64
	if((b $ bit64).and(1b64) = 0b64)
		ret n2 = 2b64
	end if
	if(n2 <= 1920000b64)
		if(n2 = 3b64)
			ret true
		end if
		var l: bit64 :: n2 % 6b64
		if(l <> 1b64 & l <> 5b64)
			ret false
		end if
		var m: bit64 :: n2 / 6b64 * 2b64 + (l = 1b64 ?(0b64, 1b64))
		; TODO:
	end if
	
	var enough: bit64
	if(n2 < 2047b64)
		do enough = 1b64
	elif(n2 < 1373653b64)
		do enough = 2b64
	elif(n2 < 25326001b64)
		do enough = 3b64
	elif(n2 < 3215031751b64)
		do enough = 4b64
	elif(n2 < 2152302898747b64)
		do enough = 5b64
	elif(n2 < 3474749660383b64)
		do enough = 6b64
	elif(n2 < 341550071728321b64)
		do enough = 7b64
	elif(n2 < 3825123056546413051b64)
		do enough = 9b64
	else
		; n2 < 2^64 < 318665857834031151167461b64
		do enough = 12b64
	end if
	
	var d: bit64 :: n2 - 1b64
	var s: bit64 :: 0b64
	while(d.and(1b64) = 0b64)
		do s :+ 1b64
		do d :: d.shr(1)
	end while
	var i: bit64 :: 0b64
	while(i < enough)
		var x: bit64 :: @modPowUnsigned(primes[i], d, n2)
		if(x = 1b64 | x = n2 - 1b64)
			skip i
		end if
		var prob: bool :: false
		var j: bit64 :: 0b64
		while loop(j < s)
			do x :: @modPowUnsigned(x, 2b64, n2)
			if(x = n2 - 1b64)
				do prob :: true
				break loop
			end if
			do j :+ 1b64
		end while
		if(!prob)
			ret false
		end if
		do i :+ 1b64
	end while
	ret true
end func

+func primeFactors(n: int): []int
	var factors: list<int> :: #list<int>
	while(n > 1)
		var factor: int :: @findFactor(n $ bit64) $ int
		do factors.add(factor)
		do n :/ factor
	end while
	var r: []int :: factors.toArray()
	do r.sort()
	ret r
	
	func findFactor(n: bit64): bit64
		var seed: bit32 :: 1b32
		while(true)
			if(n.and(1b64) = 0b64)
				ret 2b64
			end if
			if(@prime(n $ int))
				ret n
			end if
			var a: bit64 :: xorShift(&seed).shl(32)
			do a :: a.or(xorShift(&seed))
			var y: bit64 :: a % (n + 1b64)
			var c: bit64 :: xorShift(&seed) + 1b64
			var m: bit64 :: xorShift(&seed) + 1b64
			var g: bit64
			var r: bit64 :: 1b64
			var q: bit64 :: 1b64
			var ys: bit64 :: 0b64
			var x: bit64
			var i: bit64
			while(g <= 1b64, skip)
				do x :: y
				do i :: 0b64
				while(i < r)
					do y :: (@modMulUnsigned(y, y, n) + c) % n
					do i :+ 1b64
				end while
				var k: bit64 :: 0b64
				while(k < r & g <= 1b64, skip)
					do ys :: y
					var min: bit64 :: m < r - k ?(m, r - k)
					do i :: 0b64
					while(i < min)
						do y :: (@modMulUnsigned(y, y, n) + c) % n
						do q :: @modMulUnsigned(q, x > y ?(x - y, y - x), n)
						do i :+ 1b64
					end while
					do g :: @gcd(q $ int, n $ int) $ bit64
					do k :+ m
				end while
				do r :* 2b64
			end while
			if(g = n)
				while(g <= 1b64, skip)
					do ys :: (@modMulUnsigned(ys, ys, n) + c) % n
					do g :: @gcd((x > ys ?(x - ys, ys - x)) $ int, n $ int) $ bit64
				end while
			end if
			if(g = n)
				do seed :+ 1b32
			else
				do n :: g
			end if
		end while
	end func
	
	func xorShift(seed: &bit32): bit64
		var x: bit32 :: seed
		do x :: x.xor(x.shl(13))
		do x :: x.xor(x.shr(17))
		do x :: x.xor(x.shl(5))
		do seed :: x
		ret x $ bit64
	end func
end func

+func[__raw, math_gamma]gamma(n: float): float
end func

+func fact(n: float): float
	ret @gamma(n + 1.0)
end func

+func factInt(n: int): int
	; TODO: Refactoring.
	if(n < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(n > 20)
		throw excpt@dbgIntOverflow
	end if
	var result: int :: 1
	for i(1, n)
		do result :* i
	end for
	ret result
end func

+func fibonacci(n: int): int
	; TODO: Refactoring.
	if(n < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(n > 92)
		throw excpt@dbgIntOverflow
	end if
	if(n = 0)
		ret 0
	end if
	var a: int :: 0
	var b: int :: 1
	for i(2, n)
		var t: int :: a + b
		do a :: b
		do b :: t
	end for
	ret b
end func

+func knapsack(weights: []int, values: []int, maxWeight: int, reuse: bool): int
	; TODO: Refactoring.
	var dp: []int :: #[maxWeight + 1]int
	if(reuse)
		for i(0, ^weights - 1)
			var j: int :: weights[i]
			while(j <= maxWeight)
				var value: int :: dp[j - weights[i]] + values[i]
				if(dp[j] < value)
					do dp[j] :: value
				end if
				do j :+ 1
			end while
		end for
	else
		for i(0, ^weights - 1)
			var j: int :: maxWeight
			while(j >= weights[i])
				var value: int :: dp[j - weights[i]] + values[i]
				if(dp[j] < value)
					do dp[j] :: value
				end if
				do j :- 1
			end while
		end for
	end if
	ret dp[maxWeight]
end func

+func[__raw, math_dijkstra]dijkstra(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func[__raw, math_bellmanFord]bellmanFord(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func[d0003.knd, _floydWarshall]floydWarshall(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int): [][]int
end func

func modPowUnsigned(value: bit64, exponent: bit64, modulus: bit64): bit64
	var w: bit64 :: 1b64
	while(exponent > 0b64)
		if(exponent.and(1b64) <> 0b64)
			do w :: modMulUnsigned(w, value, modulus)
		end if
		do value :: modMulUnsigned(value, value, modulus)
		do exponent :: exponent.shr(1)
	end while
	ret w
end func

func modMulUnsigned(a: bit64, b: bit64, modulus: bit64): bit64
	var w: bit64 :: 0
	while(a > 0b64)
		if(a.and(1b64) <> 0b64)
			do w :: (w + b) % modulus
		end if
		do b :: b.shl(1) % modulus
		do a :: a.shr(1)
	end while
	ret w
end func
