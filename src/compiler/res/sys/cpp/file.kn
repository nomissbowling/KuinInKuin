+enum Origin
	head
	cur
	tail
end enum

+class Reader()
	*func[__ndc]ctor()
	end func
	
	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func delimiter(delimiters: []char)
		do me.delimiters :: delimiters
	end func
	
	+func fileSize(): int
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		ret me.size
	end func
	
	+func fin()
		if(me.size >= 0)
			do @readerClose(me.handle)
			do me.size :: -1
		end if
	end func
	
	+func getPos(): int
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		ret me.cur
	end func
	
	+func read(size: int): []bit8
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		var r: []bit8 :: #[size]bit8
		if(@readerReadImpl(me.handle, r, 0, size))
			ret r
		end if
		ret null
	end func
	
	+func readChar(): char
		while loop(true)
			var c: char :: me.readCharWithDelimiters()
			if(c <> '\0')
				if(c = '\uFFFF')
					throw 0xE9170008
				end if
				do me.skipDelimiters()
				ret c
			end if
		end while
	end func
	
	+func readFloat(): float
		var s: []char :: me.readStr()
		var b: bool
		var r: float :: s.toFloat(&b)
		if(!b)
			throw 0xE9170008
		end if
		ret r
	end func
	
	+func readInt(): int
		var s: []char :: me.readStr()
		var b: bool
		var r: int :: s.toInt(&b)
		if(!b)
			throw 0xE9170008
		end if
		ret r
	end func
	
	+func readLetter(): char
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		
		; TODO: 文字コード
	end func
	
	+func readLine(): []char
		var buf: []char :: #[strBufSize]char
		var ptr: int :: 0
		while loop(true)
			var c: char :: me.readLetter()
			if(c = '\u000D')
				skip loop
			end if
			if(c = '\uFFFF')
				if(ptr = 0)
					ret null
				end if
				break loop
			end if
			if(c = '\n')
				break loop
			end if
			if(ptr = ^buf)
				do buf :~ #[strBufSize]char
			end if
			do buf[ptr] :: c
			do ptr :+ 1
		end while
		ret buf.sub(0, ptr)
	end func
	
	+func readStr(): []char
		var buf: []char :: #[strBufSize]char
		var ptr: int :: 0
		while loop(true)
			var c: char :: me.readCharWithDelimiters()
			if(c = '\uFFFF')
				if(ptr = 0)
					throw 0xE9170008
				end if
				break loop
			end if
			if(c = '\0')
				if(ptr = 0)
					skip loop
				end if
				break loop
			end if
			if(ptr = ^buf)
				do buf :~ #[strBufSize]char
			end if
			do buf[ptr] :: c
			do ptr :+ 1
		end while
		do me.skipDelimiters()
		ret buf.sub(0, ptr)
	end func
	
	+func setPos(origin: @Origin, pos: int)
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
			if(origin < %head | %tail < origin)
				throw 0xE9170006
			end if
		end if
		do @readerSeekImpl(me.handle, origin, pos)
		do me.cur :: @readerTellImpl(me.handle)
	end func
	
	+func term(): bool
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		ret me.cur >= me.size
	end func
	
	func readCharWithDelimiters(): char
		while loop(true)
			var c: char :: me.readLetter()
			for i(0, ^me.delimiters - 1)
				if(c = me.delimiters[i] | (c = '\u000D' & me.delimiters[i] = '\n'))
					ret '\0'
				end if
			end for
			if(c = '\u000D')
				skip loop
			end if
			ret c
		end while
	end func
	
	func skipDelimiters()
		while loop(true)
			var c: char :: me.readLetter()
			for i(0, ^me.delimiters - 1)
				if(c = me.delimiters[i] | (c = '\u000D' & me.delimiters[i] = '\n'))
					skip loop
				end if
			end for
			if(c = '\u000D')
				skip loop
			end if
			if(c <> '\uFFFF')
				do me.setPos(%cur, -1)
			end if
			ret
		end while
	end func
	
	const strBufSize: int :: 1024
	+var handle: int
	+var size: int
	+var cur: int
	+var delimiters: []char
end class

+class Writer()
	*func[__ndc]ctor()
	end func

	*func[__frc]_dtor()
		do me.fin()
	end func
	
	+func fileSize(): int
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		ret me.size
	end func
	
	+func fin()
		if(me.size >= 0)
			do @writerCloseImpl(me.handle)
			do me.handle :: -1
		end if
	end func
	
	+func flush()
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		do @writerFlushImpl(me.handle)
	end func

	+func getPos(): int
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		ret me.cur
	end func
	
	+func setPos(origin: @Origin, pos: int)
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
			if(origin < %head | %tail < origin)
				throw 0xE9170006
			end if
		end if
		do @writerSeekImpl(me.handle, origin, pos)
		do me.cur :: @writerTellImpl(me.handle)
	end func
	
	+func write(bin: []bit8)
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		do @writerWriteImpl(me.handle, bin, 0, ^bin)
	end func
	
	+func writeChar(n: char)
		if(dbg)
			if(me.size < 0)
				throw 0xE917000A
			end if
		end if
		; TODO: 文字コード
	end func
	
	+func writeFloat(n: float)
		var s: []char :: n.toStr()
		for i(0, ^s - 1)
			do me.writeChar(s[i])
		end for
	end func
	
	+func writeInt(n: int)
		var s: []char :: n.toStr()
		for i(0, ^s - 1)
			do me.writeChar(s[i])
		end for
	end func
	
	+func writeStr(n: []char)
		for i(0, ^n - 1)
			do me.writeChar(n[i])
		end for
	end func
	
	+var handle: int
	+var size: int
	+var cur: int
end class

+func copyDir(dst: []char, src: []char): bool
	; TODO:
end func

+func copyFile(dst: []char, src: []char): bool
	ret false {TODO:}
end func

+func delDir(path: []char): bool
	; TODO:
end func

+func delExt(path: []char): []char
	var p: int :: ^path - 1
	while(p >= 0 & path[p] <> '/' & path[p] <> '\\' & path[p] <> '.')
		do p :- 1
	end while
	if(p < 0 | path[p] <> '.')
		do p :: ^path
	end if
	var r: []char :: #[p]char
	for i(0, p - 1)
		do r[i] :: path[i] = '\\' ?('/', path[i])
	end for
	ret r
end func

+func delFile(path: []char): bool
	; TODO:
end func

+func dir(path: []char): []char
	assert path <>& null
	var p: int :: ^path - 1
	while(p >= 0 & path[p] <> '/' & path[p] <> '\\')
		do p :- 1
	end while
	if(p < 0)
		ret "./"
	end if
	var r: []char :: #[p + 1]char
	for i(0, p)
		do r[i] :: path[i] = '\\' ?('/', path[i])
	end for
	ret r
end func

+func exeDir(): []char
	; TODO:
end func

+func exist(path: []char): bool
	excode "return fileExists_(`0`);\n"
end func

+func ext(path: []char): []char
	assert path <>& null
	var p: int :: ^path - 1
	while(p >= 0 & path[p] <> '/' & path[p] <> '\\' & path[p] <> '.')
		do p :- 1
	end while
	if(path[p] <> '.')
		ret ""
	end if
	do p :+ 1
	var r: []char :: #[^path - p]char
	for i(0, ^path - p - 1)
		do r[i] :: path[p + i]
	end for
	ret r
end func

+func fileName(path: []char): []char
	assert path <>& null
	var p: int :: ^path - 1
	while(p >= 0 & path[p] <> '/' & path[p] <> '\\')
		do p :- 1
	end while
	if(p < 0)
		ret path
	end if
	do p :+ 1
	var r: []char :: #[^path - p]char
	for i(0, ^path - p - 1)
		do r[i] :: path[p + i]
	end for
	ret r
end func

+func fileSize(path: []char): int
	; TODO:
end func

+func forEach(path: []char, recursion: bool, callback: func<([]char, bool, kuin@Class): bool>, data: kuin@Class): bool
	excode "return fileForEach_(`0`,`1`,reinterpret_cast<bool(*)(type_(Array_<char16_t>),bool,type_(Class_))>(`2`),`3`);\n"
end func

+func fullPath(path: []char): []char
	; TODO:
end func

+func getCurDir(): []char
	; TODO:
end func

+func makeDir(path: []char): bool
	; TODO:
end func

+func[__mki]makeReader(me2: @Reader, path: []char): @Reader
	var pack: bool :: path[0] = 'r' & path[1] = 'e' & path[2] = 's' & path[3] = '/'
	var success: bool
	do me2.handle :: @openAsReadingImpl(path, pack, &success)
	if(!success)
		ret null
	end if
	do me2.delimiters :: " ,\n"
	do @readerSeekImpl(me2.handle, %tail, 0)
	do me2.size :: @readerTellImpl(me2.handle)
	do @readerSeekImpl(me2.handle, %head, 0)
	do me2.cur :: 0
	ret me2
end func

+func[__mki]makeWriter(me2: @Writer, path: []char, append: bool): @Writer
	var success: bool
	do me2.handle :: @openAsWritingImpl(path, append, &success)
	if(!success)
		ret null
	end if
	if(append)
		do @writerSeekImpl(me2.handle, %tail, 0)
		do me2.size :: @writerTellImpl(me2.handle)
		do @writerSeekImpl(me2.handle, %head, 0)
	else
		do me2.size :: 0
	end if
	do me2.cur :: 0
	ret me2
end func

+func moveDir(dst: []char, src: []char): bool
	; TODO:
end func

+func moveFile(dst: []char, src: []char): bool
	; TODO:
end func

+func setCurDir(path: []char)
	; TODO:
end func

func openAsReadingImpl(path: []char, pack: bool, success: &bool): int
	excode "std::u16string s_=`0`->B;\n"
	excode "const std::string&t_=utf16ToUtf8_(s_);\n"
	excode "std::FILE*f_=std::fopen(t_.c_str(),\"rb\");\n"
	excode "if(f_==nullptr){\n"
	excode "*`2`=false;\n"
	excode "return 0;\n"
	excode "}\n"
	excode "*`2`=true;\n"
	excode "return reinterpret_cast<int64_t>(f_);\n"
end func

func readerClose(handle: int)
	excode "fclose(reinterpret_cast<std::FILE*>(`0`));\n"
end func

func readerSeekImpl(handle: int, origin: @Origin, pos: int)
	excode "#if defined(_WIN32)\n"
	excode "_fseeki64(reinterpret_cast<std::FILE*>(`0`),`2`,static_cast<int>(`1`));\n"
	excode "#else\n"
	excode "fseeko(reinterpret_cast<std::FILE*>(`0`),`2`,static_cast<int>(`1`));\n"
	excode "#endif\n"
end func

func readerTellImpl(handle: int): int
	excode "#if defined(_WIN32)\n"
	excode "return _ftelli64(reinterpret_cast<std::FILE*>(`0`));\n"
	excode "#else\n"
	excode "return ftello(reinterpret_cast<std::FILE*>(`0`));\n"
	excode "#endif\n"
end func

func readerReadImpl(handle: int, buf: []bit8, start: int, size: int): bool
	excode "return fread(`1`->B+`2`,1,`3`,reinterpret_cast<std::FILE*>(`0`))==`3`;\n"
end func

func openAsWritingImpl(path: []char, append: bool, success: &bool): int
	excode "std::u16string s_=`0`->B;\n"
	excode "const std::string&t_=utf16ToUtf8_(s_);\n"
	excode "std::FILE*f_=std::fopen(t_.c_str(),`1`?\"ab\":\"wb\");\n"
	excode "if(f_==nullptr){\n"
	excode "*`2`=false;\n"
	excode "return 0;\n"
	excode "}\n"
	excode "*`2`=true;\n"
	excode "return reinterpret_cast<int64_t>(f_);\n"
end func

func writerCloseImpl(handle: int)
	excode "fclose(reinterpret_cast<std::FILE*>(`0`));\n"
end func

func writerFlushImpl(handle: int)
	excode "fflush(reinterpret_cast<std::FILE*>(`0`));\n"
end func

func writerSeekImpl(handle: int, origin: @Origin, pos: int)
	excode "#if defined(_WIN32)\n"
	excode "_fseeki64(reinterpret_cast<std::FILE*>(`0`),`2`,static_cast<int>(`1`));\n"
	excode "#else\n"
	excode "fseeko(reinterpret_cast<std::FILE*>(`0`),`2`,static_cast<int>(`1`));\n"
	excode "#endif\n"
end func

func writerTellImpl(handle: int): int
	excode "#if defined(_WIN32)\n"
	excode "return _ftelli64(reinterpret_cast<std::FILE*>(`0`));\n"
	excode "#else\n"
	excode "return ftello(reinterpret_cast<std::FILE*>(`0`));\n"
	excode "#endif\n"
end func

func writerWriteImpl(handle: int, data: []bit8, start: int, size: int)
	excode "fwrite(`1`->B+`2`,1,`3`,reinterpret_cast<std::FILE*>(`0`));\n"
end func
