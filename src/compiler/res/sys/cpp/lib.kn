+const e: float :: 2.71828182845904523536
+const intMax: int :: 9223372036854775807
+const intMin: int :: -9223372036854775807 - 1
+const pi: float :: 3.14159265358979323846

func _init()
	do @globalRnd :: #@Rnd
	do @globalRnd.setSeed((@sysTime() $ bit32).xor(@now() $ bit32))
end func

+class BmSearch()
	*func[d0000.knd, _bmSearchDtor, __frc]_dtor()
		; TODO:
	end func
	
	+func[d0000.knd, _bmSearchFind]find(text: []char, start: int): int
		; TODO:
	end func
	
	var pattern: int
	var dists: int
	var len: int
end class

+class Bool()
	+*func cmp(t: @Bool): int
		ret(me.value $ int - t.value $ int).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: bool
end class

+class Char()
	+*func cmp(t: @Char): int
		ret(me.value $ int - t.value $ int).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: char
end class

+class Float()
	+*func cmp(t: @Float): int
		ret(me.value - t.value).sign() $ int
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: float
end class

+class Int()
	+*func cmp(t: @Int): int
		ret(me.value - t.value).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: int
end class

+class Rnd()
	+func rnd(min: int, max: int): int
		if(dbg)
			if(min > max)
				throw 0xE9170006
			end if
		end if
		var n: bit64 :: (max - min + 1) $ bit64
		var m: bit64 :: 0b64 - ((0b64 - n) % n)
		var r: bit64
		if(m = 0b64)
			do r :: (me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64)
		else
			while(m <= r, skip)
				do r :: (me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64)
			end while
		end if
		ret(r % n) $ int + min
	end func
	
	+func rndBit64(): bit64
		ret(me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64)
	end func
	
	+func rndFloat(min: float, max: float): float
		if(dbg)
			if(min > max)
				throw 0xE9170006
			end if
		end if
		ret(me.xs128() $ bit64).shl(32).or(me.xs128() $ bit64) $ float / 18446744073709551616.0 * (max - min) + min
	end func
	
	+func setSeed(seed: bit32)
		do me.x :: 123456789b32
		do me.y :: 362436069b32
		do me.z :: 521288629b32 * seed
		do me.w :: 88675123b32 * me.z.shr(1)
	end func
	
	func xs128(): bit32
		var t: bit32 :: me.x.xor(me.x.shl(11))
		do me.x :: me.y
		do me.y :: me.z
		do me.z :: me.w
		do me.w :: me.w.xor(me.w.shr(19)).xor(t.xor(t.shr(8)))
		ret me.w
	end func
	
	var x: bit32
	var y: bit32
	var z: bit32
	var w: bit32
end class

+class Str()
	+*func cmp(t: @Str): int
		ret @cmp(me.value, t.value)
	end func
	
	+*func toStr(): []char
		ret me.value
	end func
	
	+var value: []char
end class

var globalRnd: @Rnd

+func acos(x: float): float
	excode "return std::acos(`0`);\n"
end func

+func acosh(x: float): float
	excode "return std::acosh(`0`);\n"
end func

+func addr(class_: kuin@Class): bit64
	excode "return addr_(`0`);\n"
end func

+func asin(x: float): float
	excode "return std::asin(`0`);\n"
end func

+func asinh(x: float): float
	excode "return std::asinh(`0`);\n"
end func

+func atan(x: float): float
	excode "return std::atan(`0`);\n"
end func

+func atanh(x: float): float
	excode "return std::atanh(`0`);\n"
end func

+func ceil(x: float): float
	excode "return std::ceil(`0`);\n"
end func

+func cerp(first: float, last: float, rate: float): float
	; TODO:
end func

+func chase(x: &float, target: float, vel: float): bool
	if(x = target)
		ret true
	end if
	if(x < target)
		do x :+ vel
		if(x >= target)
			do x :: target
			ret true
		end if
	else
		do x :- vel
		if(x <= target)
			do x :: target
			ret true
		end if
	end if
	ret false
end func

+func cmdLine(): [][]char
	excode "auto a_=new_(Array_<type_(Array_<char16_t>)>)();\n"
	excode "a_->L=argc_;\n"
	excode "a_->B=newPrimArray_(static_cast<size_t>(argc_),type_(Array_<char16_t>));\n"
	excode "for(int64_t i_=0;i_<argc_;i_++){\n"
	excode "std::string s_=argv_[i_];\n"
	excode "const std::u16string t_=utf8ToUtf16_(s_);\n"
	excode "a_->B[i_]=new_(Array_<char16_t>)();\n"
	excode "a_->B[i_]->L=static_cast<int64_t>(t_.size());\n"
	excode "a_->B[i_]->B=newPrimArray_(t_.size()+1,char16_t);\n"
	excode "std::memcpy(a_->B[i_]->B,t_.c_str(),sizeof(char16_t)*(t_.size()+1));\n"
	excode "}\n"
	excode "return a_;\n"
end func

+func cmp(s1: []char, s2: []char): int
	var p: int :: 0
	while(p < ^s1 & p < ^s2)
		if(s1[p] <> s2[p])
			ret s1[p] > s2[p] ?(1, s1[p] < s2[p] ?(-1, 0))
		end if
		do p :+ 1
	end while
	ret ^ s1 > ^s2 ?(1, ^s1 < ^s2 ?(-1, 0))
end func

+func[d0000.knd, _cmpEx]cmpEx(s1: []char, s2: []char, len: int, ignoreCase: bool): int
	; TODO:
end func

+func cos(x: float): float
	excode "return std::cos(`0`);\n"
end func

+func cosh(x: float): float
	excode "return std::cosh(`0`);\n"
end func

+func[d0000.knd, _countUp]countUp(min: int, max: int): []int
	; TODO:
end func

+func dateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int
	assert 1 <= month & month <= 12 & 1 <= day & day <= 31 & 0 <= hour & hour <= 23 & 0 <= minute & minute <= 59 & 0 <= second & second <= 59
	var a: int :: year - (month <= 2 ?(1, 0))
	var b: int :: (a >= 0 ?(a, a - 399)) / 400
	var c: int :: a - b * 400
	var d: int :: (153 * (month + (month > 2 ?(-3, 9))) + 2) / 5 + day - 1
	ret(b * 146097 + c * 365 + c / 4 - c / 100 + d - 719468) * 86400 + hour * 3600 + minute * 60 + second
end func

+func dist(x: float, y: float, centerX: float, centerY: float): float
	excode "return std::hypot(`0`-`2`,`1`-`3`);\n"
end func

+func exitCode(code: int)
	if(dbg)
		if(code < 0 | 0xFFFFFFFF < code)
			throw 0xE9170006
		end if
	end if
	excode "exitCode_=`0`;\n"
end func

+func exp(x: float): float
	excode "return std::exp(`0`);\n"
end func

+func floor(x: float): float
	excode "return std::floor(`0`);\n"
end func

+func hermite(pos: []float, rate: float): float
	; TODO:
end func

+func intToDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int
	var t: int :: time + 719468 * 86400
	var a: int :: t / 86400
	var b: int :: (a >= 0 ?(a, a - 146096)) / 146097
	var c: int :: a - b * 146097
	var d: int :: (c - c / 1460 + c / 36524 - c / 146096) / 365
	var e: int :: c - (365 * d + d / 4 - d / 100)
	var f: int :: (5 * e + 2) / 153
	do day :: e - (153 * f + 2) / 5 + 1
	do month :: f + (f < 10 ?(3, -9))
	do year :: d + b * 400 + (month <= 2 ?(1, 0))
	var s: int :: t % 86400
	do hour :: s / 3600
	do s :- hour * 3600
	do minute :: s / 60
	do second :: s - minute * 60
	var g: int :: a - 719468
	ret g >= -4 ?((g + 4) % 7, (g + 5) % 7 + 6)
end func

+func[d0000.knd, _intToLocalDate]intToLocalDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int
	; TODO:
end func

+func invRot(x: float, y: float, centerX: float, centerY: float): float
	excode "double r_=std::atan2(`1`-`3`,`0`-`2`);\n"
	excode "return r_< 0.0?r_+2.0*3.14159265358979323846:r_;\n"
end func

+func lerp(first: float, last: float, rate: float): float
	; TODO:
end func

+func levenshtein(s1: []char, s2: []char): int
	; TODO:
end func

+func ln(x: float): float
	excode "return std::log(`0`);\n"
end func

+func[d0000.knd, _localDateToInt]localDateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int
	; TODO:
end func

+func log(base: float, x: float): float
	ret @ln(x) / @ln(base)
end func

+func[d0000.knd, _makeBmSearch, __mki]makeBmSearch(me2: @BmSearch, pattern: []char): @BmSearch
	; TODO:
end func

+func makeRnd(seed: bit32): @Rnd
	var r: @Rnd :: #@Rnd
	do r.setSeed(seed)
	ret r
end func

+func max(n1: int, n2: int): int
	ret n1 >= n2 ?(n1, n2)
end func

+func maxFloat(n1: float, n2: float): float
	ret n1 >= n2 ?(n1, n2)
end func

+func min(n1: int, n2: int): int
	ret n1 <= n2 ?(n1, n2)
end func

+func minFloat(n1: float, n2: float): float
	ret n1 <= n2 ?(n1, n2)
end func

+func now(): int
	excode "return std::time(nullptr);\n"
end func

+func padding(value: int, align: int): int
	ret(align - 1) - (value + align - 1) % align
end func

+func qerp(first: float, last: float, easeIn: bool, rate: float): float
	; TODO:
end func

+func rnd(min: int, max: int): int
	ret @globalRnd.rnd(min, max)
end func

+func rndBit64(): bit64
	ret @globalRnd.rndBit64()
end func

+func rndFloat(min: float, max: float): float
	ret @globalRnd.rndFloat(min, max)
end func

+func rndUuid(): []char
	var r: []char :: #[36]char
	var r1: bit64 :: @rndBit64()
	var r2: bit64 :: @rndBit64()
	var p: int :: 0
	for i(0, 35)
		switch(i)
		case 8, 13, 18, 23
			do r[i] :: '-'
			skip i
		end switch
		var n: bit64 :: ((p <= 15 ?(r1, r2)).shr(p % 16 * 4)).and(0x0Fb64)
		if(p = 12)
			do n :: 4b64
		elif(p = 16)
			do n :: n.and(0x03b64).or(0x08b64)
		end if
		do r[i] :: n <= 9b64 ?(('0' $ bit64 + n) $ char, ('a' $ bit64 + n - 10b64) $ char)
		do p :+ 1
	end for
	ret r
end func

+func rot(x: &float, y: &float, centerX: float, centerY: float, angle: float)
	var x2: float :: x - centerX
	var y2: float :: y - centerY
	var cosTheta: float :: @cos(angle)
	var sinTheta: float :: @sin(angle)
	var x3: float :: x2 * cosTheta - y2 * sinTheta
	var y3: float :: x2 * sinTheta + y2 * cosTheta
	do x :: x3 + centerX
	do y :: y3 + centerY
end func

+func round(x: float, precision: int): float
	if(precision = 0)
		ret x >= 0.0 ?(@floor(x + 0.5), -@floor(-x + 0.5))
	else
		var p: float :: 10.0 ^ (precision $ float)
		ret x >= 0.0 ?(@floor(x * p + 0.5) / p, -@floor(-x * p + 0.5) / p)
	end if
end func

+func same(n1: float, n2: float): bool
	var i1: bit64 :: @toBit64Forcibly(n1)
	var i2: bit64 :: @toBit64Forcibly(n2)
	if(i1.shr(63) <> i2.shr(63))
		ret i1 = i2
	end if
	var diff: int :: (i1 - i2) $ int
	ret - 24 <= diff & diff <= 24
end func

+func sin(x: float): float
	excode "return std::sin(`0`);\n"
end func

+func sinh(x: float): float
	excode "return std::sinh(`0`);\n"
end func

+func[d0000.knd]sleep(ms: int)
	; TODO:
end func

+func sqrt(x: float): float
	excode "return std::sqrt(`0`);\n"
end func

+func sysTime(): int
	excode "return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n"
end func

+func tan(x: float): float
	excode "return std::tan(`0`);\n"
end func

+func tanh(x: float): float
	excode "return std::tanh(`0`);\n"
end func

+func toBit64Forcibly(x: float): bit64
	excode "return *(uint64_t*)&`0`;\n"
end func

+func toDegree(rad: float): float
	ret rad * 180.0 / @pi
end func

+func toFloatForcibly(x: bit64): float
	excode "return *(double*)&`0`;\n"
end func

+func toRad(degree: float): float
	ret degree * @pi / 180.0
end func
