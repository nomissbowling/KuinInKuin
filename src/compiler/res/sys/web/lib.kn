+const e: float :: 2.71828182845904523536
+const intMax: int :: 9223372036854775807
+const intMin: int :: -9223372036854775807 - 1
+const pi: float :: 3.14159265358979323846

func _init()
	do @globalRnd :: #@Rnd
	do @globalRnd.setSeed((@sysTime() $ bit32).xor(@now() $ bit32))
end func

+class Bool()
	+*func cmp(t: @Bool): int
		ret(me.value $ int - t.value $ int).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: bool
end class

+class Char()
	+*func cmp(t: @Char): int
		ret(me.value $ int - t.value $ int).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: char
end class

+class Float()
	+*func cmp(t: @Float): int
		ret(me.value - t.value).sign() $ int
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: float
end class

+class Int()
	+*func cmp(t: @Int): int
		ret(me.value - t.value).sign()
	end func
	
	+*func toStr(): []char
		ret me.value.toStr()
	end func
	
	+var value: int
end class

+class Rnd()
	+func rnd(min: int, max: int): int
		if(dbg)
			if(max - min < 0)
				throw 0xE9170006
			end if
		end if
		var n: bit64 :: (max - min + 1) $ bit64
		var m: bit64 :: 0b64 - ((0b64 - n) % n)
		var r: bit64
		if(m = 0b64)
			do r :: me.rndBit64()
		else
			while(m <= r, skip)
				do r :: me.rndBit64()
			end while
		end if
		ret(r % n) $ int + min
	end func
	
	+func rndBit64(): bit64
		var t: bit32 :: me.xs128()
		ret(t $ bit64).shl(32).or(me.xs128() $ bit64)
	end func
	
	+func rndFloat(min: float, max: float): float
		if(dbg)
			if(min >= max)
				throw 0xE9170006
			end if
		end if
		ret me.rndBit64() $ float / 18446744073709551616.0 * (max - min) + min
	end func
	
	+func setSeed(seed: bit32)
		do me.x :: 123456789b32
		do me.y :: 362436069b32
		do me.z :: 521288629b32 * seed
		do me.w :: 88675123b32 * me.z.shr(1)
	end func
	
	func xs128(): bit32
		var t: bit32 :: me.x.xor(me.x.shl(11))
		do me.x :: me.y
		do me.y :: me.z
		do me.z :: me.w
		do me.w :: me.w.xor(me.w.shr(19)).xor(t.xor(t.shr(8)))
		ret me.w
	end func
	
	var x: bit32
	var y: bit32
	var z: bit32
	var w: bit32
end class

+class Str()
	+*func cmp(t: @Str): int
		ret @cmp(me.value, t.value)
	end func
	
	+*func toStr(): []char
		ret me.value
	end func
	
	+var value: []char
end class

var globalRnd: @Rnd

+func acos(x: float): float
	excode "return Math.acos(`0`);\n"
end func

+func acosh(x: float): float
	excode "return Math.log(`0`+Math.sqrt(`0`*`0`-1));\n"
end func

+func addr(class_: kuin@Class): bit64
	excode "return Uint32Array.from([0,`0`.A_]);\n"
end func

+func asin(x: float): float
	excode "return Math.asin(`0`);\n"
end func

+func asinh(x: float): float
	excode "return Math.log(`0`+Math.sqrt(`0`*`0`+1));\n"
end func

+func atan(x: float): float
	excode "return Math.atan(`0`);\n"
end func

+func atanh(x: float): float
	excode "return 0.5*Math.log((1+`0`)/(1-`0`));\n"
end func

+func ceil(x: float): float
	excode "return Math.ceil(`0`);\n"
end func

+func cerp(first: float, last: float, rate: float): float
	; TODO:
end func

+func chase(x: &float, target: float, vel: float): bool
	if(x = target)
		ret true
	end if
	if(x < target)
		do x :+ vel
		if(x >= target)
			do x :: target
			ret true
		end if
	else
		do x :- vel
		if(x <= target)
			do x :: target
			ret true
		end if
	end if
	ret false
end func

func clampFloat(x: float, min: float, max: float): float
	if(dbg)
		if(min > max)
			throw 0xE9170006
		end if
	end if
	ret x > max ?(max, x < min ?(min, x))
end func

func clamp(x: int, min: int, max: int): int
	if(dbg)
		if(min > max)
			throw 0xE9170006
		end if
	end if
	ret x > max ?(max, x < min ?(min, x))
end func

+func cmdLine(): [][]char
	excode "let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\"&\");\n"
	excode "if(r_.length==1&&r_[0]==\"\")return[];\n"
	excode "for(let i_=0;i_<r_.length;i_++)\n"
	excode "r_[i_]={S:r_[i_]};\n"
	excode "return r_;\n"
end func

+func cmp(s1: []char, s2: []char): int
	var p: int :: 0
	while(p < ^s1 & p < ^s2)
		if(s1[p] <> s2[p])
			ret s1[p] > s2[p] ?(1, s1[p] < s2[p] ?(-1, 0))
		end if
		do p :+ 1
	end while
	ret ^ s1 > ^s2 ?(1, ^s1 < ^s2 ?(-1, 0))
end func

+func cmpEx(s1: []char, s2: []char, len: int, ignoreCase: bool): int
	; TODO:
end func

+func cos(x: float): float
	excode "return Math.cos(`0`);\n"
end func

+func cosh(x: float): float
	excode "return Math.cosh(`0`);\n"
end func

+func dateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int
	assert 1 <= month & month <= 12 & 1 <= day & day <= 31 & 0 <= hour & hour <= 23 & 0 <= minute & minute <= 59 & 0 <= second & second <= 59
	var a: int :: year - (month <= 2 ?(1, 0))
	var b: int :: (a >= 0 ?(a, a - 399)) / 400
	var c: int :: a - b * 400
	var d: int :: (153 * (month + (month > 2 ?(-3, 9))) + 2) / 5 + day - 1
	ret(b * 146097 + c * 365 + c / 4 - c / 100 + d - 719468) * 86400 + hour * 3600 + minute * 60 + second
end func

+func dist(x: float, y: float, centerX: float, centerY: float): float
	excode "let x_=`0`-`2`,y_=`1`-`3`;\n"
	excode "return Math.sqrt(x_*x_+y_*y_);\n"
end func

; TODO: 'exe'
+func exitCode(code: int)
	if(dbg)
		if(code < 0 | 0xFFFFFFFF < code)
			throw 0xE9170006
		end if
	end if
end func

+func exp(x: float): float
	excode "return Math.exp(`0`);\n"
end func

+func floor(x: float): float
	excode "return Math.floor(`0`);\n"
end func

+func hermite(pos: []float, rate: float): float
	; TODO:
end func

+func intToDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int
	var t: int :: time + 719468 * 86400
	var a: int :: t / 86400
	var b: int :: (a >= 0 ?(a, a - 146096)) / 146097
	var c: int :: a - b * 146097
	var d: int :: (c - c / 1460 + c / 36524 - c / 146096) / 365
	var e: int :: c - (365 * d + d / 4 - d / 100)
	var f: int :: (5 * e + 2) / 153
	do day :: e - (153 * f + 2) / 5 + 1
	do month :: f + (f < 10 ?(3, -9))
	do year :: d + b * 400 + (month <= 2 ?(1, 0))
	var s: int :: t % 86400
	do hour :: s / 3600
	do s :- hour * 3600
	do minute :: s / 60
	do second :: s - minute * 60
	var g: int :: a - 719468
	ret g >= -4 ?((g + 4) % 7, (g + 5) % 7 + 6)
end func

+func intToLocalDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int
	; TODO:
end func

+func invRot(x: float, y: float, centerX: float, centerY: float): float
	excode "let r_=Math.atan2(`1`-`3`,`0`-`2`);\n"
	excode "return r_<0.0?r_+2.0*Math.PI:r_;\n"
end func

+func lerp(first: float, last: float, rate: float): float
	; TODO:
end func

+func levenshtein(s1: []char, s2: []char): int
	; TODO:
end func

+func ln(x: float): float
	excode "return Math.log(`0`);\n"
end func

+func localDateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int
	; TODO:
end func

+func log(base: float, x: float): float
	ret @ln(x) / @ln(base)
end func

+func makeRnd(seed: bit32): @Rnd
	var r: @Rnd :: #@Rnd
	do r.setSeed(seed)
	ret r
end func

+func max(n1: int, n2: int): int
	ret n1 >= n2 ?(n1, n2)
end func

+func maxFloat(n1: float, n2: float): float
	ret n1 >= n2 ?(n1, n2)
end func

+func min(n1: int, n2: int): int
	ret n1 <= n2 ?(n1, n2)
end func

+func minFloat(n1: float, n2: float): float
	ret n1 <= n2 ?(n1, n2)
end func

+func now(): int
	excode "let n_=Math.floor(new Date().getTime()/1000);\n"
	excode "return Uint32Array.from([Math.floor(n_/0x100000000),n_%0x100000000]);\n"
end func

+func padding(value: int, align: int): int
	ret(align - 1) - (value + align - 1) % align
end func

+func qerp(first: float, last: float, easeIn: bool, rate: float): float
	; TODO:
end func

+func range(start: int, end_: int, step: int): []int
	; TODO:
end func

+func rnd(min: int, max: int): int
	ret @globalRnd.rnd(min, max)
end func

+func rndBit64(): bit64
	ret @globalRnd.rndBit64()
end func

+func rndFloat(min: float, max: float): float
	ret @globalRnd.rndFloat(min, max)
end func

+func rndUuid(): []char
	var r: []char :: #[36]char
	var r1: bit64 :: @rndBit64()
	var r2: bit64 :: @rndBit64()
	var p: int :: 0
	for i(0, 35)
		switch(i)
		case 8, 13, 18, 23
			do r[i] :: '-'
			skip i
		end switch
		var n: bit64 :: ((p <= 15 ?(r1, r2)).shr(p % 16 * 4)).and(0x0Fb64)
		if(p = 12)
			do n :: 4b64
		elif(p = 16)
			do n :: n.and(0x03b64).or(0x08b64)
		end if
		do r[i] :: n <= 9b64 ?(('0' $ bit64 + n) $ char, ('a' $ bit64 + n - 10b64) $ char)
		do p :+ 1
	end for
	ret r
end func

+func rot(x: &float, y: &float, centerX: float, centerY: float, angle: float)
	var x2: float :: x - centerX
	var y2: float :: y - centerY
	var cosTheta: float :: @cos(angle)
	var sinTheta: float :: @sin(angle)
	var x3: float :: x2 * cosTheta - y2 * sinTheta
	var y3: float :: x2 * sinTheta + y2 * cosTheta
	do x :: x3 + centerX
	do y :: y3 + centerY
end func

+func round(x: float, precision: int): float
	if(precision = 0)
		ret x >= 0.0 ?(@floor(x + 0.5), -@floor(-x + 0.5))
	else
		var p: float :: 10.0 ^ (precision $ float)
		ret x >= 0.0 ?(@floor(x * p + 0.5) / p, -@floor(-x * p + 0.5) / p)
	end if
end func

+func same(n1: float, n2: float): bool
	var i1: bit64 :: @toBit64Forcibly(n1)
	var i2: bit64 :: @toBit64Forcibly(n2)
	if(i1.shr(63) <> i2.shr(63))
		ret i1 = i2
	end if
	var diff: int :: (i1 - i2) $ int
	ret - 24 <= diff & diff <= 24
end func

+func shuffle(n: int): []int
	if(dbg)
		if(n < 0)
			throw 0xE9170006
		end if
	end if
	var a: []int :: #[n]int
	for i(0, n - 1)
		do a[i] :: i
	end for
	for i(0, n - 1)
		var r: int :: @rnd(i, n - 1)
		if(i = r)
			skip i
		end if
		do a[i] :$ a[r]
	end for
	ret a
end func

+func sin(x: float): float
	excode "return Math.sin(`0`);\n"
end func

+func sinh(x: float): float
	excode "return Math.sinh(`0`);\n"
end func

+func sleep(ms: int)
	; TODO:
end func

+func sqrt(x: float): float
	excode "return Math.sqrt(`0`);\n"
end func

+func sysTime(): int
	excode "let n_=new Date().getTime();\n"
	excode "return Uint32Array.from([Math.floor(n_/0x100000000),n_%0x100000000]);\n"
end func

+func tan(x: float): float
	excode "return Math.tan(`0`);\n"
end func

+func tanh(x: float): float
	excode "return Math.tanh(`0`);\n"
end func

+func toBit64Forcibly(x: float): bit64
	excode "let b_=new ArrayBuffer(8),f_=new Float64Array(b_),i_=new Uint32Array(b_);\n"
	excode "f_[0]=`0`;\n"
	excode "return Uint32Array.from([i_[1],i_[0]]);\n"
end func

+func toDegree(rad: float): float
	ret rad * 180.0 / @pi
end func

+func toFloatForcibly(x: bit64): float
	excode "let b_=new ArrayBuffer(8),f_=new Float64Array(b_),i_=new Uint32Array(b_);\n"
	excode "i_[0]=`0`[1];\n"
	excode "i_[1]=`0`[0];\n"
	excode "return f_[0];\n"
end func

+func toRad(degree: float): float
	ret degree * @pi / 180.0
end func
