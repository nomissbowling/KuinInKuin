var rcon: []bit8
var sbox: []bit8
var invSbox: []bit8

func _init()
	do @rcon :: [
	|0x01b8, 0x02b8, 0x04b8, 0x08b8,
	|0x10b8, 0x20b8, 0x40b8, 0x80b8,
	|0x1Bb8, 0x36b8]
	
	do @sbox :: [
	|0x63b8, 0x7Cb8, 0x77b8, 0x7Bb8, 0xF2b8, 0x6Bb8, 0x6Fb8, 0xC5b8, 0x30b8, 0x01b8, 0x67b8, 0x2Bb8, 0xFEb8, 0xD7b8, 0xABb8, 0x76b8,
	|0xCAb8, 0x82b8, 0xC9b8, 0x7Db8, 0xFAb8, 0x59b8, 0x47b8, 0xF0b8, 0xADb8, 0xD4b8, 0xA2b8, 0xAFb8, 0x9Cb8, 0xA4b8, 0x72b8, 0xC0b8,
	|0xB7b8, 0xFDb8, 0x93b8, 0x26b8, 0x36b8, 0x3Fb8, 0xF7b8, 0xCCb8, 0x34b8, 0xA5b8, 0xE5b8, 0xF1b8, 0x71b8, 0xD8b8, 0x31b8, 0x15b8,
	|0x04b8, 0xC7b8, 0x23b8, 0xC3b8, 0x18b8, 0x96b8, 0x05b8, 0x9Ab8, 0x07b8, 0x12b8, 0x80b8, 0xE2b8, 0xEBb8, 0x27b8, 0xB2b8, 0x75b8,
	|0x09b8, 0x83b8, 0x2Cb8, 0x1Ab8, 0x1Bb8, 0x6Eb8, 0x5Ab8, 0xA0b8, 0x52b8, 0x3Bb8, 0xD6b8, 0xB3b8, 0x29b8, 0xE3b8, 0x2Fb8, 0x84b8,
	|0x53b8, 0xD1b8, 0x00b8, 0xEDb8, 0x20b8, 0xFCb8, 0xB1b8, 0x5Bb8, 0x6Ab8, 0xCBb8, 0xBEb8, 0x39b8, 0x4Ab8, 0x4Cb8, 0x58b8, 0xCFb8,
	|0xD0b8, 0xEFb8, 0xAAb8, 0xFBb8, 0x43b8, 0x4Db8, 0x33b8, 0x85b8, 0x45b8, 0xF9b8, 0x02b8, 0x7Fb8, 0x50b8, 0x3Cb8, 0x9Fb8, 0xA8b8,
	|0x51b8, 0xA3b8, 0x40b8, 0x8Fb8, 0x92b8, 0x9Db8, 0x38b8, 0xF5b8, 0xBCb8, 0xB6b8, 0xDAb8, 0x21b8, 0x10b8, 0xFFb8, 0xF3b8, 0xD2b8,
	|0xCDb8, 0x0Cb8, 0x13b8, 0xECb8, 0x5Fb8, 0x97b8, 0x44b8, 0x17b8, 0xC4b8, 0xA7b8, 0x7Eb8, 0x3Db8, 0x64b8, 0x5Db8, 0x19b8, 0x73b8,
	|0x60b8, 0x81b8, 0x4Fb8, 0xDCb8, 0x22b8, 0x2Ab8, 0x90b8, 0x88b8, 0x46b8, 0xEEb8, 0xB8b8, 0x14b8, 0xDEb8, 0x5Eb8, 0x0Bb8, 0xDBb8,
	|0xE0b8, 0x32b8, 0x3Ab8, 0x0Ab8, 0x49b8, 0x06b8, 0x24b8, 0x5Cb8, 0xC2b8, 0xD3b8, 0xACb8, 0x62b8, 0x91b8, 0x95b8, 0xE4b8, 0x79b8,
	|0xE7b8, 0xC8b8, 0x37b8, 0x6Db8, 0x8Db8, 0xD5b8, 0x4Eb8, 0xA9b8, 0x6Cb8, 0x56b8, 0xF4b8, 0xEAb8, 0x65b8, 0x7Ab8, 0xAEb8, 0x08b8,
	|0xBAb8, 0x78b8, 0x25b8, 0x2Eb8, 0x1Cb8, 0xA6b8, 0xB4b8, 0xC6b8, 0xE8b8, 0xDDb8, 0x74b8, 0x1Fb8, 0x4Bb8, 0xBDb8, 0x8Bb8, 0x8Ab8,
	|0x70b8, 0x3Eb8, 0xB5b8, 0x66b8, 0x48b8, 0x03b8, 0xF6b8, 0x0Eb8, 0x61b8, 0x35b8, 0x57b8, 0xB9b8, 0x86b8, 0xC1b8, 0x1Db8, 0x9Eb8,
	|0xE1b8, 0xF8b8, 0x98b8, 0x11b8, 0x69b8, 0xD9b8, 0x8Eb8, 0x94b8, 0x9Bb8, 0x1Eb8, 0x87b8, 0xE9b8, 0xCEb8, 0x55b8, 0x28b8, 0xDFb8,
	|0x8Cb8, 0xA1b8, 0x89b8, 0x0Db8, 0xBFb8, 0xE6b8, 0x42b8, 0x68b8, 0x41b8, 0x99b8, 0x2Db8, 0x0Fb8, 0xB0b8, 0x54b8, 0xBBb8, 0x16b8]
	
	do @invSbox :: [
	|0x52b8, 0x09b8, 0x6Ab8, 0xD5b8, 0x30b8, 0x36b8, 0xA5b8, 0x38b8, 0xBFb8, 0x40b8, 0xA3b8, 0x9Eb8, 0x81b8, 0xF3b8, 0xD7b8, 0xFBb8,
	|0x7Cb8, 0xE3b8, 0x39b8, 0x82b8, 0x9Bb8, 0x2Fb8, 0xFFb8, 0x87b8, 0x34b8, 0x8Eb8, 0x43b8, 0x44b8, 0xC4b8, 0xDEb8, 0xE9b8, 0xCBb8,
	|0x54b8, 0x7Bb8, 0x94b8, 0x32b8, 0xA6b8, 0xC2b8, 0x23b8, 0x3Db8, 0xEEb8, 0x4Cb8, 0x95b8, 0x0Bb8, 0x42b8, 0xFAb8, 0xC3b8, 0x4Eb8,
	|0x08b8, 0x2Eb8, 0xA1b8, 0x66b8, 0x28b8, 0xD9b8, 0x24b8, 0xB2b8, 0x76b8, 0x5Bb8, 0xA2b8, 0x49b8, 0x6Db8, 0x8Bb8, 0xD1b8, 0x25b8,
	|0x72b8, 0xF8b8, 0xF6b8, 0x64b8, 0x86b8, 0x68b8, 0x98b8, 0x16b8, 0xD4b8, 0xA4b8, 0x5Cb8, 0xCCb8, 0x5Db8, 0x65b8, 0xB6b8, 0x92b8,
	|0x6Cb8, 0x70b8, 0x48b8, 0x50b8, 0xFDb8, 0xEDb8, 0xB9b8, 0xDAb8, 0x5Eb8, 0x15b8, 0x46b8, 0x57b8, 0xA7b8, 0x8Db8, 0x9Db8, 0x84b8,
	|0x90b8, 0xD8b8, 0xABb8, 0x00b8, 0x8Cb8, 0xBCb8, 0xD3b8, 0x0Ab8, 0xF7b8, 0xE4b8, 0x58b8, 0x05b8, 0xB8b8, 0xB3b8, 0x45b8, 0x06b8,
	|0xD0b8, 0x2Cb8, 0x1Eb8, 0x8Fb8, 0xCAb8, 0x3Fb8, 0x0Fb8, 0x02b8, 0xC1b8, 0xAFb8, 0xBDb8, 0x03b8, 0x01b8, 0x13b8, 0x8Ab8, 0x6Bb8,
	|0x3Ab8, 0x91b8, 0x11b8, 0x41b8, 0x4Fb8, 0x67b8, 0xDCb8, 0xEAb8, 0x97b8, 0xF2b8, 0xCFb8, 0xCEb8, 0xF0b8, 0xB4b8, 0xE6b8, 0x73b8,
	|0x96b8, 0xACb8, 0x74b8, 0x22b8, 0xE7b8, 0xADb8, 0x35b8, 0x85b8, 0xE2b8, 0xF9b8, 0x37b8, 0xE8b8, 0x1Cb8, 0x75b8, 0xDFb8, 0x6Eb8,
	|0x47b8, 0xF1b8, 0x1Ab8, 0x71b8, 0x1Db8, 0x29b8, 0xC5b8, 0x89b8, 0x6Fb8, 0xB7b8, 0x62b8, 0x0Eb8, 0xAAb8, 0x18b8, 0xBEb8, 0x1Bb8,
	|0xFCb8, 0x56b8, 0x3Eb8, 0x4Bb8, 0xC6b8, 0xD2b8, 0x79b8, 0x20b8, 0x9Ab8, 0xDBb8, 0xC0b8, 0xFEb8, 0x78b8, 0xCDb8, 0x5Ab8, 0xF4b8,
	|0x1Fb8, 0xDDb8, 0xA8b8, 0x33b8, 0x88b8, 0x07b8, 0xC7b8, 0x31b8, 0xB1b8, 0x12b8, 0x10b8, 0x59b8, 0x27b8, 0x80b8, 0xECb8, 0x5Fb8,
	|0x60b8, 0x51b8, 0x7Fb8, 0xA9b8, 0x19b8, 0xB5b8, 0x4Ab8, 0x0Db8, 0x2Db8, 0xE5b8, 0x7Ab8, 0x9Fb8, 0x93b8, 0xC9b8, 0x9Cb8, 0xEFb8,
	|0xA0b8, 0xE0b8, 0x3Bb8, 0x4Db8, 0xAEb8, 0x2Ab8, 0xF5b8, 0xB0b8, 0xC8b8, 0xEBb8, 0xBBb8, 0x3Cb8, 0x83b8, 0x53b8, 0x99b8, 0x61b8,
	|0x17b8, 0x2Bb8, 0x04b8, 0x7Eb8, 0xBAb8, 0x77b8, 0xD6b8, 0x26b8, 0xE1b8, 0x69b8, 0x14b8, 0x63b8, 0x55b8, 0x21b8, 0x0Cb8, 0x7Db8]
end func

+func encrypt(data: []bit8, key: []bit8): []bit8
	if(dbg)
		if(^key <> 32)
			throw 0xE9170006
		end if
	end if
	if(^data % 16 <> 0)
		do data :~ #[16 - ^data % 16]bit8
	end if
	var buf: []bit8 :: #[^data]bit8
	var w: []bit8 :: @keyExpansion(key)
	var cur: []bit8 :: #[16]bit8
	var old: []bit8 :: #[16]bit8
	var cw: []bit8 :: #[16]bit8
	var dataIdx: int :: 0
	var bufIdx: int :: 0
	var len: int :: ^data
	while(len > 0)
		for i(0, 16 - 1)
			do cur[i] :: data[dataIdx + i].xor(old[i])
		end for
		do @addRoundKey(cur, w, 0)
		for i(1, 13)
			do @subBytes(cur)
			do @shiftRows(cur, cw)
			do @mixColumns(cur)
			do @addRoundKey(cur, w, i)
		end for
		do @subBytes(cur)
		do @shiftRows(cur, cw)
		do @addRoundKey(cur, w, 14)
		for i(0, 16 - 1)
			do buf[bufIdx + i] :: cur[i]
			do old[i] :: cur[i]
		end for
		do dataIdx :+ 16
		do bufIdx :+ 16
		do len :- 16
	end while
	ret buf
end func

+func decrypt(data: []bit8, key: []bit8): []bit8
	if(dbg)
		if(^data % 16 <> 0 | ^key <> 32)
			throw 0xE9170006
		end if
	end if
	var buf: []bit8 :: #[^data]bit8
	var w: []bit8 :: @keyExpansion(key)
	var cur: []bit8 :: #[16]bit8
	var old: []bit8 :: #[16]bit8
	var tmp: []bit8 :: #[16]bit8
	var cw: []bit8 :: #[16]bit8
	var dataIdx: int :: 0
	var bufIdx: int :: 0
	var len: int :: ^data
	while(len > 0)
		for i(0, 16 - 1)
			do cur[i] :: data[dataIdx + i]
			do tmp[i] :: old[i]
			do old[i] :: cur[i]
		end for
		do @addRoundKey(cur, w, 14)
		for i(13, 1, -1)
			do @invShiftRows(cur, cw)
			do @invSubBytes(cur)
			do @addRoundKey(cur, w, i)
			do @invMixColumns(cur)
		end for
		do @invShiftRows(cur, cw)
		do @invSubBytes(cur)
		do @addRoundKey(cur, w, 0)
		for i(0, 16 - 1)
			do cur[i] :: cur[i].xor(tmp[i])
			do buf[bufIdx + i] :: cur[i]
		end for
		do dataIdx :+ 16
		do bufIdx :+ 16
		do len :- 16
	end while
	ret buf
end func

func keyExpansion(key: []bit8): []bit8
	var w: []bit8 :: key ~ #[4 * 60]bit8
	var tmp: []bit8 :: #[4]bit8
	for i(8, 60 - 1)
		do tmp[0] :: w[4 * (i - 1)]
		do tmp[1] :: w[4 * (i - 1) + 1]
		do tmp[2] :: w[4 * (i - 1) + 2]
		do tmp[3] :: w[4 * (i - 1) + 3]
		if(i % 8 = 0)
			var t: bit8 :: @sbox[tmp[0] $ int]
			do tmp[0] :: @sbox[tmp[1] $ int].xor(@rcon[i / 8 - 1])
			do tmp[1] :: @sbox[tmp[2] $ int]
			do tmp[2] :: @sbox[tmp[3] $ int]
			do tmp[3] :: t
		elif(i % 8 = 4)
			do tmp[0] :: @sbox[tmp[0] $ int]
			do tmp[1] :: @sbox[tmp[1] $ int]
			do tmp[2] :: @sbox[tmp[2] $ int]
			do tmp[3] :: @sbox[tmp[3] $ int]
		end if
		do w[4 * i] :: w[4 * (i - 8)].xor(tmp[0])
		do w[4 * i + 1] :: w[4 * (i - 8) + 1].xor(tmp[1])
		do w[4 * i + 2] :: w[4 * (i - 8) + 2].xor(tmp[2])
		do w[4 * i + 3] :: w[4 * (i - 8) + 3].xor(tmp[3])
	end for
	ret w
end func

func addRoundKey(data: []bit8, w: []bit8, n: int)
	for i(0, 16 - 1)
		do data[i] :: data[i].xor(w[16 * n + i])
	end for
end func

func subBytes(data: []bit8)
	for i(0, 16 - 1)
		do data[i] :: @sbox[data[i] $ int]
	end for
end func

func shiftRows(data: []bit8, cw: []bit8)
	for i(0, 16 - 1)
		do cw[i] :: data[i]
	end for
	for i(1, 4 - 1)
		do cw[i + 0 * 4] :: data[i + (i + 0) % 4 * 4]
		do cw[i + 1 * 4] :: data[i + (i + 1) % 4 * 4]
		do cw[i + 2 * 4] :: data[i + (i + 2) % 4 * 4]
		do cw[i + 3 * 4] :: data[i + (i + 3) % 4 * 4]
	end for
	for i(0, 16 - 1)
		do data[i] :: cw[i]
	end for
end func

func mixColumns(data: []bit8)
	for i(0, 4 - 1)
		var i4: int :: i * 4
		var x: bit32 :: @mul(data[i4 + 0], 2).xor(@mul(data[i4 + 1], 3)).xor(@mul(data[i4 + 2], 1)).xor(@mul(data[i4 + 3], 1))
		do x :: x.or(@mul(data[i4 + 1], 2).xor(@mul(data[i4 + 2], 3)).xor(@mul(data[i4 + 3], 1)).xor(@mul(data[i4 + 0], 1)).shl(8))
		do x :: x.or(@mul(data[i4 + 2], 2).xor(@mul(data[i4 + 3], 3)).xor(@mul(data[i4 + 0], 1)).xor(@mul(data[i4 + 1], 1)).shl(16))
		do x :: x.or(@mul(data[i4 + 3], 2).xor(@mul(data[i4 + 0], 3)).xor(@mul(data[i4 + 1], 1)).xor(@mul(data[i4 + 2], 1)).shl(24))
		do data[i4] :: x $ bit8
		do data[i4 + 1] :: x.shr(8) $ bit8
		do data[i4 + 2] :: x.shr(16) $ bit8
		do data[i4 + 3] :: x.shr(24) $ bit8
	end for
end func

func mul(dt: bit8, n: int): bit32
	var dt2: bit32 :: dt $ bit32
	var n2: bit32 :: n $ bit32
	var i: bit32 :: 8b32
	var x: bit32 :: 0b32
	while(i > 0b32)
		do x :: x.shl(1)
		if(x.and(0x100b32) <> 0b32)
			do x :: x.xor(0x1Bb32).and(0xFFb32)
		end if
		if(n2.and(i) <> 0b32)
			do x :: x.xor(dt2)
		end if
		do i :: i.shr(1)
	end while
	ret x
end func

func invSubBytes(data: []bit8)
	for i(0, 16 - 1)
		do data[i] :: @invSbox[data[i] $ int]
	end for
end func

func invShiftRows(data: []bit8, cw: []bit8)
	for i(0, 16 - 1)
		do cw[i] :: data[i]
	end for
	for i(1, 4 - 1)
		do cw[i + (i + 0) % 4 * 4] :: data[i + 0 * 4]
		do cw[i + (i + 1) % 4 * 4] :: data[i + 1 * 4]
		do cw[i + (i + 2) % 4 * 4] :: data[i + 2 * 4]
		do cw[i + (i + 3) % 4 * 4] :: data[i + 3 * 4]
	end for
	for i(0, 16 - 1)
		do data[i] :: cw[i]
	end for
end func

func invMixColumns(data: []bit8)
	for i(0, 4 - 1)
		var i4: int :: i * 4
		var x: bit32 :: @mul(data[i4 + 0], 14).xor(@mul(data[i4 + 1], 11)).xor(@mul(data[i4 + 2], 13)).xor(@mul(data[i4 + 3], 9))
		do x :: x.or(@mul(data[i4 + 1], 14).xor(@mul(data[i4 + 2], 11)).xor(@mul(data[i4 + 3], 13)).xor(@mul(data[i4 + 0], 9)).shl(8))
		do x :: x.or(@mul(data[i4 + 2], 14).xor(@mul(data[i4 + 3], 11)).xor(@mul(data[i4 + 0], 13)).xor(@mul(data[i4 + 1], 9)).shl(16))
		do x :: x.or(@mul(data[i4 + 3], 14).xor(@mul(data[i4 + 0], 11)).xor(@mul(data[i4 + 1], 13)).xor(@mul(data[i4 + 2], 9)).shl(24))
		do data[i4] :: x $ bit8
		do data[i4 + 1] :: x.shr(8) $ bit8
		do data[i4 + 2] :: x.shr(16) $ bit8
		do data[i4 + 3] :: x.shr(24) $ bit8
	end for
end func
