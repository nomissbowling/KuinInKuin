func[d0001.knd, _init]_init()
end func

func[d0001.knd, _fin]_fin()
end func

+enum Anchor
	fix
	move
	scale
end enum

+class Wnd(@WndBase)
	*func[d0001.knd, _wndBaseDtor, _force]_dtor()
	end func
	
	+func[d0001.knd, _wndAcceptDraggedFiles]acceptDraggedFiles(isAccepted: bool)
	end func
	
	+func[d0001.knd, _wndActivate]activate()
	end func
	
	+func[d0001.knd, _wndActivated]activated(): bool
	end func
	
	+func[d0001.knd, _wndClose]close()
	end func
	
	+func[d0001.knd, _wndExit]exit()
	end func
	
	+func[d0001.knd, _wndFocusedWnd]focusedWnd(): bool
	end func
	
	+func[d0001.knd, _wndGetAlpha]getAlpha(): int
	end func
	
	+func[d0001.knd, _wndGetText]getText(): []char
	end func
	
	+func[d0001.knd, _wndMinMax]minMax(minWidth: int, minHeight: int, maxWidth: int, maxHeight: int)
	end func
	
	+func modal()
		do setModalLock(me)
		while(@act() & me.modalLock)
		end while
		
		func[d0001.knd, _wndSetModalLock]setModalLock(me_: @WndBase)
		end func
	end func
	
	+func[d0001.knd, _wndSetAlpha]setAlpha(alpha: int)
	end func
	
	+func[d0001.knd, _wndSetMenu]setMenu(menu: @Menu)
		if(menu <>& null)
			do me.addChild(menu)
		end if
	end func
	
	+func[d0001.knd, _wndSetText]setText(text: []char)
	end func
	
	+func[d0001.knd, _wndUpdateMenu]updateMenu()
	end func
	
	var minMaxRect: int
	+var onClose: func<(@Wnd): bool>
	+var onActivate: func<(@Wnd, bool, bool)>
	+var onPushMenu: func<(@Wnd, int)>
	+var onDropFiles: func<(@Wnd, [][]char)>
	+var onResize: func<(@Wnd)>
	var modalLock: bool
end class

+class WndBase()
	*func[__ndc]ctor()
	end func
	
	*func[d0001.knd, _wndBaseDtor, _force]_dtor()
	end func
	
	+func addChild(child: kuin@Class)
		do me.children.add(child)
	end func
	
	+func[d0001.knd, _wndBaseClientToScreen]clientToScreen(screenX: &int, screenY: &int, clientX: int, clientY: int)
	end func
	
	+func findChild(name: []char): @WndBase
		if(dbg)
			if(name =& null)
				throw 0xE9170006
			end if
		end if
		ret findRecursion(me, name)
		
		func findRecursion(wnd: @WndBase, name: []char): @WndBase
			if(wnd.name <>& null & wnd.name = name)
				ret wnd
			end if
			do wnd.children.head()
			while(!wnd.children.term())
				var child: kuin@Class :: wnd.children.get()
				if(child =$ @WndBase)
					var result: @WndBase :: findRecursion(child $ @WndBase, name)
					if(result <>& null)
						ret result
					end if
				end if
				do wnd.children.next()
			end while
			ret null
		end func
	end func
	
	+func[d0001.knd, _wndBaseFocus]focus()
	end func
	
	+func[d0001.knd, _wndBaseFocused]focused(): bool
	end func
	
	+func[d0001.knd, _wndBaseGetEnabled]getEnabled(): bool
	end func
	
	+func[d0001.knd, _wndBaseGetPos]getPos(x: &int, y: &int, width: &int, height: &int)
	end func
	
	+func[d0001.knd, _wndBaseGetPosScreen]getPosScreen(x: &int, y: &int, width: &int, height: &int)
	end func
	
	+func[d0001.knd, _wndBaseGetVisible]getVisible(): bool
	end func
	
	+func[d0001.knd, _wndBaseScreenToClient]screenToClient(clientX: &int, clientY: &int, screenX: int, screenY: int)
	end func
	
	+func[d0001.knd, _wndBaseSetEnabled]setEnabled(isEnabled: bool)
	end func
	
	+func[d0001.knd, _wndBaseSetPos]setPos(x: int, y: int, width: int, height: int)
	end func
	
	+func[d0001.knd, _wndBaseSetRedraw]setRedraw(isEnabled: bool)
	end func
	
	+func[d0001.knd, _wndBaseSetVisible]setVisible(isVisible: bool)
	end func
	
	+var name: []char
	var kind: int
	var handle: int
	var defaultWndProc: int
	var ctrlFlag: int
	var defaultRect: int
	var redrawEnabled: int
	+var children: list<kuin@Class>
end class

+enum WndStyle
	normal
	fix
	aspect
	popup
	dialog
	layered :: 0x10000
	noMinimize :: 0x20000
end enum

+func[d0001.knd, _act]act(): bool
end func
