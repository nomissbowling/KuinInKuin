+class DocAr(\doc_gen@DocDesigner)
	*func ctor()
		do super(me)
		do me.undo :: #undo@Undo
		do me.undo.init(1024)

		do me.nodes :: #list<@Obj>
		do me.holds :: #list<@Obj>
		do me.clipboard :: #list<@Obj>
		do me.scrollOffsetX :: 10
		do me.scrollOffsetY :: 40
		do me.pageX :: -me.scrollOffsetX
		do me.pageY :: -me.scrollOffsetY
		do me.mode :: %none
		do me.updatingProp :: false
	end func

	+*func getSrc(): [][]char
		ret me.src
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, \common@colorBack)
		block
			if(^me.holds = 0)
				var objX: int
				var objY: int
				var objWidth: int
				var objHeight: int
				do me.resizeObj(me.root, me.curOriginX, me.curOriginY, &objX, &objY, &objWidth, &objHeight)
				var x: float :: (objX - me.pageX) $ float
				var y: float :: (objY - me.pageY) $ float
				var width2: float :: objWidth $ float
				var height2: float :: objHeight $ float
				if(me.root.visible)
					do me.root.draw(x, y, width2, height2, \form@zoom)
				end if
				do draw@rectLine((x - 3.0) * \form@zoom, (y - 3.0) * \form@zoom, (width2 + 6.0) * \form@zoom, (height2 + 6.0) * \form@zoom, 0xFF6666FF)
				do draw@rectLine((x - 4.0) * \form@zoom, (y - 4.0) * \form@zoom, (width2 + 8.0) * \form@zoom, (height2 + 8.0) * \form@zoom, 0xFF6666FF)
				do draw@rectLine(x * \form@zoom, y * \form@zoom, width2 * \form@zoom, height2 * \form@zoom, 0x80000000)
			else
				var x: float :: (me.root.x - me.pageX) $ float
				var y: float :: (me.root.y - me.pageY) $ float
				var width2: float :: me.root.width $ float
				var height2: float :: me.root.height $ float
				if(me.root.visible)
					do me.root.draw(x, y, width2, height2, \form@zoom)
				end if
				do draw@rectLine(x * \form@zoom, y * \form@zoom, width2 * \form@zoom, height2 * \form@zoom, 0x80000000)
			end if
		end block
		do me.nodes.head()
		while(!me.nodes.term())
			var node: @Obj :: me.nodes.get()
			do me.holds.head()
			if(me.holds.find(node))
				var objX: int
				var objY: int
				var objWidth: int
				var objHeight: int
				do me.resizeObj(node, me.curOriginX, me.curOriginY, &objX, &objY, &objWidth, &objHeight)
				var x: float :: (objX - me.pageX) $ float
				var y: float :: (objY - me.pageY) $ float
				var width2: float :: objWidth $ float
				var height2: float :: objHeight $ float
				if(node.visible)
					do node.draw(x, y, width2, height2, \form@zoom)
				end if
				do draw@rectLine((x - 3.0) * \form@zoom, (y - 3.0) * \form@zoom, (width2 + 6.0) * \form@zoom, (height2 + 6.0) * \form@zoom, 0xFF6666FF)
				do draw@rectLine((x - 4.0) * \form@zoom, (y - 4.0) * \form@zoom, (width2 + 8.0) * \form@zoom, (height2 + 8.0) * \form@zoom, 0xFF6666FF)
				do draw@blend(%exclusion)
				do draw@rectLine(x * \form@zoom, y * \form@zoom, width2 * \form@zoom, height2 * \form@zoom, 0xFF808080)
				do draw@blend(%alpha)
			else
				var x: float :: (node.x - me.pageX) $ float
				var y: float :: (node.y - me.pageY) $ float
				var width2: float :: node.width $ float
				var height2: float :: node.height $ float
				if(node.visible)
					do node.draw(x, y, width2, height2, \form@zoom)
				end if
				do draw@blend(%exclusion)
				do draw@rectLine(x * \form@zoom, y * \form@zoom, width2 * \form@zoom, height2 * \form@zoom, 0xFF808080)
				do draw@blend(%alpha)
			end if
			do me.nodes.next()
		end while

		if(me.mode = %sel)
			do draw@rectLine((me.holdOriginX - me.pageX) $ float * \form@zoom, (me.holdOriginY - me.pageY) $ float * \form@zoom, (me.curOriginX - me.holdOriginX) $ float * \form@zoom, (me.curOriginY - me.holdOriginY) $ float * \form@zoom, 0xFF6666FF)
		end if
	end func

	+*func mouseDownL(x: int, y: int)
		var x2: int :: (x $ float / \form@zoom) $ int + me.pageX
		var y2: int :: (y $ float / \form@zoom) $ int + me.pageY
		do me.holdOriginX :: x2
		do me.holdOriginY :: y2
		do me.curOriginX :: x2
		do me.curOriginY :: y2

		var idx: int :: \form@listLt.getSel()
		if(idx <= 0)
			var sel: @Obj :: null
			do me.nodes.tail()
			while loop(!me.nodes.term())
				var obj: @Obj :: me.nodes.get()
				if(obj.x <= x2 & x2 <= obj.x + obj.width & obj.y <= y2 & y2 <= obj.y + obj.height)
					do sel :: obj
					break loop
				end if
				do me.nodes.prev()
			end while
			if(sel =& null & me.root.x <= x2 & x2 <= me.root.x + me.root.width & me.root.y <= y2 & y2 <= me.root.y + me.root.height)
				do sel :: me.root
			end if

			if(sel =& null)
				do me.mode :: %sel
			elif(sel <> me.root)
				var resizeAreaX: int
				var resizeAreaY: int
				do @getResizeArea(&resizeAreaX, &resizeAreaY, sel.width, sel.height)
				if(sel.x + sel.width - resizeAreaX <= x2)
					if (\form@getLockingEditor())
						do \form@showMsgRunning()
						ret
					end if
					if(sel.y + sel.height - resizeAreaY <= y2)
						do me.mode :: %resizeRB
					elif(y2 <= sel.y + resizeAreaY)
						do me.mode :: %resizeRT
					else
						do me.mode :: %resizeR
					end if
				elif(x2 <= sel.x + resizeAreaX)
					if (\form@getLockingEditor())
						do \form@showMsgRunning()
						ret
					end if
					if(sel.y + sel.height - resizeAreaY <= y2)
						do me.mode :: %resizeLB
					elif(y2 <= sel.y + resizeAreaY)
						do me.mode :: %resizeLT
					else
						do me.mode :: %resizeL
					end if
				elif(sel.y + sel.height - resizeAreaY <= y2)
					if (\form@getLockingEditor())
						do \form@showMsgRunning()
						ret
					end if
					do me.mode :: %resizeB
				elif(y2 <= sel.y + resizeAreaY)
					if (\form@getLockingEditor())
						do \form@showMsgRunning()
						ret
					end if
					do me.mode :: %resizeT
				else
					do me.mode :: %move
				end if
			else
				var resizeAreaX: int
				var resizeAreaY: int
				do @getResizeArea(&resizeAreaX, &resizeAreaY, sel.width, sel.height)
				if(sel.x + sel.width - resizeAreaX <= x2)
					if (\form@getLockingEditor())
						do \form@showMsgRunning()
						ret
					end if
					if(sel.y + sel.height - resizeAreaY <= y2)
						do me.mode :: %resizeRB
					else
						do me.mode :: %resizeR
					end if
				elif(sel.y + sel.height - resizeAreaY <= y2)
					if (\form@getLockingEditor())
						do \form@showMsgRunning()
						ret
					end if
					do me.mode :: %resizeB
				else
					do me.mode :: %sel
				end if
			end if

			if(sel =& me.root)
				do sel :: null
			end if
			if(sel =& null)
				if(!wnd@key(%shift) & !wnd@key(%ctrl))
					do me.holds :: #list<@Obj>
				end if
			else
				do me.holds.head()
				if (!me.holds.find(sel))
					if(wnd@key(%shift) | wnd@key(%ctrl))
						do me.holds.add(sel)
					else
						do me.holds :: #list<@Obj>
						do me.holds.add(sel)
					end if
				end if
			end if
			do \form@updateUi()
		else
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			var name: []char :: \form@listLt.getText(&, idx, 0)
			var parent: []char :: null
			if(^me.holds > 0)
				do me.holds.tail()
				do me.nodes.head()
				if(me.nodes.find(me.holds.get()))
					do me.nodes.next()
					if(!me.nodes.term())
						do parent :: me.nodes.get().name
					end if
				end if
			end if
			do me.mode :: %put
			do me.undo.recordBegin()
			do me.holds :: #list<@Obj>
			var objX: int
			var objY: int
			var objWidth: int
			var objHeight: int
			var obj: @Obj :: me.put(parent, name, @getDefaultName(name.lower(), me.nodes), true, x2, y2, -1, -1, null, true)
			do me.holds.add(obj)
			do me.resizeObj(obj, 0, 0, &objX, &objY, &objWidth, &objHeight)
			do me.move(obj.name, objX, objY, objWidth, objHeight, true)
			do me.undo.recordEnd()
			do \form@updateUi()
		end if
		do \form@paintDrawEditor()
	end func

	+*func mouseUpL(x: int, y: int)
		switch(me.mode)
		case %put, %move, %resizeLT, %resizeRT, %resizeLB, %resizeRB, %resizeL, %resizeT, %resizeR, %resizeB
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			var arrangedX: int :: (x $ float / \form@zoom) $ int + me.pageX
			var arrangedY: int :: (y $ float / \form@zoom) $ int + me.pageY
			do me.arrange(&arrangedX, &arrangedY)
			do me.undo.recordBegin()
			var objX: int
			var objY: int
			var objWidth: int
			var objHeight: int
			if(^me.holds = 0)
				do me.resizeObj(me.root, arrangedX, arrangedY, &objX, &objY, &objWidth, &objHeight)
				do me.move(null, objX, objY, objWidth, objHeight, true)
			else
				do me.holds.head()
				while(!me.holds.term())
					var obj: @Obj :: me.holds.get()
					do me.resizeObj(obj, arrangedX, arrangedY, &objX, &objY, &objWidth, &objHeight)
					do me.move(obj.name, objX, objY, objWidth, objHeight, true)
					do me.holds.next()
				end while
			end if
			do me.undo.recordEnd()
			do me.mode :: %none
			if(me.mode = %put)
				do \form@listLt.setSel(0)
			end if
			do \form@updateUi()
			do \form@paintDrawEditor()
		case %sel
			var x1: int :: me.holdOriginX
			var y1: int :: me.holdOriginY
			var x2: int :: (x $ float / \form@zoom) $ int + me.pageX
			var y2: int :: (y $ float / \form@zoom) $ int + me.pageY
			if(x1 > x2)
				do x1 :$ x2
			end if
			if(y1 > y2)
				do y1 :$ y2
			end if
			if(!wnd@key(%shift) & !wnd@key(%ctrl))
				do me.holds :: #list<@Obj>
			end if
			do me.nodes.head()
			while(!me.nodes.term())
				var node: @Obj :: me.nodes.get()
				if(node.x <= x2 & x1 <= node.x + node.width & node.y <= y2 & y1 <= node.y + node.height)
					do me.holds.add(node)
				end if
				do me.nodes.next()
			end while
			do me.mode :: %none
			do \form@updateUi()
			do \form@paintDrawEditor()
		end switch
	end func

	+*func mouseDoubleClick(x: int, y: int)
	end func

	+*func mouseMove(x: int, y: int)
		switch(me.mode)
		case %put, %move, %resizeLT, %resizeRT, %resizeLB, %resizeRB, %resizeL, %resizeT, %resizeR, %resizeB
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			var arrangedX: int :: (x $ float / \form@zoom) $ int + me.pageX
			var arrangedY: int :: (y $ float / \form@zoom) $ int + me.pageY
			do me.arrange(&arrangedX, &arrangedY)
			do me.curOriginX :: arrangedX
			do me.curOriginY :: arrangedY
			do me.updateProp()
			do \form@paintDrawEditor()
		case %sel
			do me.curOriginX :: (x $ float / \form@zoom) $ int + me.pageX
			do me.curOriginY :: (y $ float / \form@zoom) $ int + me.pageY
			do \form@paintDrawEditor()
		end switch
	end func

	+*func focus(isFocus: bool)
		if(isFocus)
			do me.updateScrollBar()
		end if
	end func

	+*func updateScrollBar()
		var padding: int :: (50.0 / \form@zoom) $ int
		var screenWidth: int
		var screenHeight: int
		do \form@drawEditor.getPos(&, &, &screenWidth, &screenHeight)
		if(me.pageX > me.root.width + padding - me.scrollOffsetX - ((screenWidth $ float / \form@zoom) $ int - me.scrollOffsetX))
			do me.pageX :: me.root.width + padding - me.scrollOffsetX - ((screenWidth $ float / \form@zoom) $ int - me.scrollOffsetX)
		end if
		if (me.pageX < -me.scrollOffsetX)
			do me.pageX :: -me.scrollOffsetX
		end if
		if(me.pageY > me.root.height + padding - me.scrollOffsetY - ((screenHeight $ float / \form@zoom) $ int - me.scrollOffsetY))
			do me.pageY :: me.root.height + padding - me.scrollOffsetY - ((screenHeight $ float / \form@zoom) $ int - me.scrollOffsetY)
		end if
		if (me.pageY < -me.scrollOffsetY)
			do me.pageY :: -me.scrollOffsetY
		end if
		do \form@scrollXSrc.setState(me.root.x, me.root.width + padding, (screenWidth $ float / \form@zoom) $ int - me.scrollOffsetX, me.pageX + me.scrollOffsetX)
		do \form@scrollYSrc.setState(me.root.y, me.root.height + padding, (screenHeight $ float / \form@zoom) $ int - me.scrollOffsetY, me.pageY + me.scrollOffsetY)
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl): bool
	end func

	+*func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	end func

	+*func keyChar(key: char)
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos - me.scrollOffsetX
		do \form@paintDrawEditor()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos - me.scrollOffsetY
		do \form@paintDrawEditor()
	end func

	+*func wheelX(wheel: int)
	end func

	+*func wheelY(wheel: int)
	end func

	+*func setMouseImg(): wnd@MouseImg
		switch(me.mode)
		case %none
			var x: int
			var y: int
			do input@mousePos(&x, &y)
			do \form@drawEditor.screenToClient(&x, &y, x, y)
			do x :: (x $ float / \form@zoom) $ int + me.pageX
			do y :: (y $ float / \form@zoom) $ int + me.pageY
			do me.nodes.tail()
			while(!me.nodes.term())
				var obj: @Obj :: me.nodes.get()
				if(obj.x <= x & x <= obj.x + obj.width & obj.y <= y & y <= obj.y + obj.height)
					var resizeAreaX: int
					var resizeAreaY: int
					do @getResizeArea(&resizeAreaX, &resizeAreaY, obj.width, obj.height)
					if(obj.x + obj.width - resizeAreaX <= x)
						if(obj.y + obj.height - resizeAreaY <= y)
							ret %resizeLTRB
						end if
						if(y <= obj.y + resizeAreaY)
							ret %resizeRTLB
						end if
						ret %resizeH
					end if
					if(x <= obj.x + resizeAreaX)
						if(obj.y + obj.height - resizeAreaY <= y)
							ret %resizeRTLB
						end if
						if(y <= obj.y + resizeAreaY)
							ret %resizeLTRB
						end if
						ret %resizeH
					end if
					if(obj.y + obj.height - resizeAreaY <= y)
						ret %resizeV
					end if
					if(y <= obj.y + resizeAreaY)
						ret %resizeV
					end if
					ret %move
				end if
				do me.nodes.prev()
			end while
			if(me.root.x <= x & x <= me.root.x + me.root.width & me.root.y <= y & y <= me.root.y + me.root.height)
				var resizeAreaX: int
				var resizeAreaY: int
				do @getResizeArea(&resizeAreaX, &resizeAreaY, me.root.width, me.root.height)
				if(me.root.x + me.root.width - resizeAreaX <= x)
					if(me.root.y + me.root.height - resizeAreaY <= y)
						ret %resizeLTRB
					end if
					ret %resizeH
				end if
				if(me.root.y + me.root.height - resizeAreaY <= y)
					ret %resizeV
				end if
			end if
			ret %arrow
		case %put
			ret %cross
		case %move
			ret %move
		case %resizeLT,%resizeRB
			ret %resizeLTRB
		case %resizeRT,%resizeLB
			ret %resizeRTLB
		case %resizeL
			ret %resizeH
		case %resizeT
			ret %resizeV
		case %resizeR
			ret %resizeH
		case %resizeB
			ret %resizeV
		case %sel
			ret %cross
		default
			assert false
		end switch
	end func

	+*func cmdUndo()
		if(\form@getLockingEditor())
			do \form@showMsgRunning()
			ret
		end if
		do me.undo.undo()
		do \form@updateUi()
		do \form@paintDrawEditor()
	end func

	+*func cmdRedo()
		if(\form@getLockingEditor())
			do \form@showMsgRunning()
			ret
		end if
		do me.undo.redo()
		do \form@updateUi()
		do \form@paintDrawEditor()
	end func

	+*func cmdCut()
		if(^me.holds = 0)
			ret
		end if
		do me.cmdCopy()
		do me.cmdDel()
	end func

	+*func cmdCopy()
		if(^me.holds = 0)
			ret
		end if
		do me.clipboard :: #list<@Obj>
		do me.holds.head()
		while(!me.holds.term())
			do me.clipboard.add(me.cloneObj(me.holds.get()))
			do me.holds.next()
		end while
	end func

	+*func cmdPaste()
		if(^me.clipboard = 0)
			ret
		end if
		do me.undo.recordBegin()
		do me.clipboard.head()
		do me.holds :: #list<@Obj>
		while(!me.clipboard.term())
			var obj: @Obj :: me.clipboard.get()
			var kind: []char :: obj.kind()
			do me.holds.add(me.put(null, kind, @getDefaultName(kind.lower(), me.nodes), obj.visible, obj.x, obj.y, obj.width, obj.height, ##obj.props, true))
			do me.clipboard.next()
		end while
		do me.undo.recordEnd()
		do \form@updateUi()
		do \form@paintDrawEditor()
	end func

	+*func cmdDel()
		do me.undo.recordBegin()
		do me.holds.head()
		while(!me.holds.term())
			do me.del(me.holds.get().name, true)
			do me.holds.del()
		end while
		do me.undo.recordEnd()
		do \form@updateUi()
		do \form@paintDrawEditor()
	end func

	+*func cmdSelAll()
		do me.holds :: #list<@Obj>
		do me.nodes.head()
		while(!me.nodes.term())
			do me.holds.add(me.nodes.get())
			do me.nodes.next()
		end while
		do \form@updateUi()
		do \form@paintDrawEditor()
	end func

	+*func undoImpl(undo2: \doc@UndoCmd)
		if(undo2 =$ UndoArPut)
			var undo3: UndoArPut :: undo2 $ UndoArPut
			do me.holds :: #list<@Obj>
			do me.holds.add(me.put(undo3.parent, undo3.kind, undo3.name, undo3.visible, undo3.x, undo3.y, undo3.width, undo3.height, undo3.props, false))
		elif(undo2 =$ UndoArDel)
			var undo3: UndoArDel :: undo2 $ UndoArDel
			do me.del(undo3.name, false)
		elif(undo2 =$ UndoArMove)
			var undo3: UndoArMove :: undo2 $ UndoArMove
			do me.move(undo3.name, undo3.x, undo3.y, undo3.width, undo3.height, false)
		elif(undo2 =$ UndoArOrder)
			var undo3: UndoArOrder :: undo2 $ UndoArOrder
			do me.order(undo3.names, false)
		elif(undo2 =$ UndoArRename)
			var undo3: UndoArRename :: undo2 $ UndoArRename
			do me.rename(undo3.name, undo3.newName, false)
		elif(undo2 =$ UndoArVisible)
			var undo3: UndoArVisible :: undo2 $ UndoArVisible
			do me.visible(undo3.name, undo3.value, false)
		elif(undo2 =$ UndoArProp)
			var undo3: UndoArProp :: undo2 $ UndoArProp
			do me.prop(undo3.name, undo3.prop, undo3.value, false)
		else
			assert false
		end if
	end func

	+*func getSelCode(): []char
		ret null
	end func

	+*func updateUi()
		do \form@listLt.setRedraw(false)
		do \form@listLt.clear()
		do \form@listLt.style(%large)
		do \form@listLt.add(\common@langEn ?("Pointer", "ポインタ"), 0)
		do me.updateLt()
		do \form@listLt.setRedraw(true)

		do \form@listLb.setRedraw(false)
		do \form@listLb.clear()
		do \form@listLb.style(%list_)
		var parentStack: stack<@Obj> :: #stack<@Obj>
		do me.nodes.head()
		while(!me.nodes.term())
			var obj: @Obj :: me.nodes.get()
			do @getParent(parentStack, obj)
			do \form@listLb.add(">".repeat(^parentStack) ~ obj.name, obj.icon())
			if(obj.becomeParent())
				do parentStack.add(obj)
			end if
			do me.holds.head()
			if(me.holds.find(obj))
				do \form@listLb.setSelMulti(\form@listLb.len() - 1, true)
			end if
			do me.nodes.next()
		end while
		do \form@listLb.setRedraw(true)

		do me.updateProp()
	end func

	+*func onEvent(event: \doc@Event)
		if(me.updatingProp)
			ret
		end if
		switch(event)
		case %listLtOnMouseClick
		case %listLbOnMouseClick
			do me.holds :: #list<@Obj>
			var len: int :: \form@listLb.len()
			for i(0, len - 1)
				if(\form@listLb.getSelMulti(i))
					var name: []char :: @removePrefix(\form@listLb.getText(&, i, 0))
					do me.find(me.nodes, name)
					do me.holds.add(me.nodes.get())
				end if
			end for
			do me.updateProp()
			do \form@paintDrawEditor()
		case %listLbOnMoveNode
			var len: int :: \form@listLb.len()
			var names: [][]char :: #[len][]char
			for i(0, len - 1)
				do names[i] :: @removePrefix(\form@listLb.getText(&, i, 0))
			end for
			do me.undo.recordBegin()
			do me.order(names, true)
			do me.undo.recordEnd()
			do \form@paintDrawEditor()
			do \form@updateUi()
		case %listRbOnMouseClick
		case %editRbArNameOnKillFocus
			if(^me.holds <> 1)
				ret
			end if
			do me.holds.head()
			var obj: @Obj :: me.holds.get()
			var name: []char :: \form@editRbArName.getText().trim()
			do me.find(me.nodes, name)
			if(me.nodes.term() & me.root.name <> name)
				do me.undo.recordBegin()
				do me.rename(obj.name, name, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		case %chkRbArVisibleOnPush
			var data: lib@Bool :: #lib@Bool
			do data.value :: \form@chkRbArVisible.getChk()
			do me.updateMultiple(chk, apply, data)

			func chk(obj: @Obj, data: lib@Bool): bool
				ret obj.visible <> data.value
			end func

			func apply(me_: @DocAr, obj: @Obj, data: lib@Bool)
				do me_.visible(obj =& me_.root ?(null, obj.name), data.value, true)
			end func
		case %editRbArXOnKillFocus
			if(^me.holds = 0)
				do \form@updateUi()
				ret
			end if
			var success: bool
			var value: int :: \form@editRbArX.getText().trim().toInt(&success)
			if(success)
				if(value < 0)
					do value :: 0
				end if
				var data: lib@Int :: #lib@Int
				do data.value :: value
				do me.updateMultiple(chk, apply, data)
			else
				do \form@updateUi()
			end if

			func chk(obj: @Obj, data: lib@Int): bool
				ret obj.x <> data.value
			end func

			func apply(me_: @DocAr, obj: @Obj, data: lib@Int)
				do me_.move(obj =& me_.root ?(null, obj.name), data.value, obj.y, obj.width, obj.height, true)
			end func
		case %editRbArYOnKillFocus
			if(^me.holds = 0)
				do \form@updateUi()
				ret
			end if
			var success: bool
			var value: int :: \form@editRbArY.getText().trim().toInt(&success)
			if(success)
				if(value < 0)
					do value :: 0
				end if
				var data: lib@Int :: #lib@Int
				do data.value :: value
				do me.updateMultiple(chk, apply, data)
			else
				do \form@updateUi()
			end if

			func chk(obj: @Obj, data: lib@Int): bool
				ret obj.y <> data.value
			end func

			func apply(me_: @DocAr, obj: @Obj, data: lib@Int)
				do me_.move(obj =& me_.root ?(null, obj.name), obj.x, data.value, obj.width, obj.height, true)
			end func
		case %editRbArWidthOnKillFocus
			var success: bool
			var value: int :: \form@editRbArWidth.getText().trim().toInt(&success)
			if(success)
				var data: lib@Int :: #lib@Int
				do data.value :: value
				do me.updateMultiple(chk, apply, data)
			else
				do \form@updateUi()
			end if

			func chk(obj: @Obj, data: lib@Int): bool
				var value: int :: data.value
				var minValue: int
				var maxValue: int
				do obj.getMinMax(&minValue, &, &maxValue, &)
				if(value < minValue)
					do value :: minValue
				elif(value > maxValue)
					do value :: maxValue
				end if
				ret obj.width <> value
			end func

			func apply(me_: @DocAr, obj: @Obj, data: lib@Int)
				var value: int :: data.value
				var minValue: int
				var maxValue: int
				do obj.getMinMax(&minValue, &, &maxValue, &)
				if(value < minValue)
					do value :: minValue
				elif(value > maxValue)
					do value :: maxValue
				end if
				do me_.move(obj =& me_.root ?(null, obj.name), obj.x, obj.y, value, obj.height, true)
			end func
		case %editRbArHeightOnKillFocus
			var success: bool
			var value: int :: \form@editRbArHeight.getText().trim().toInt(&success)
			if(success)
				var data: lib@Int :: #lib@Int
				do data.value :: value
				do me.updateMultiple(chk, apply, data)
			else
				do \form@updateUi()
			end if

			func chk(obj: @Obj, data: lib@Int): bool
				var value: int :: data.value
				var minValue: int
				var maxValue: int
				do obj.getMinMax(&, &minValue, &, &maxValue)
				if(value < minValue)
					do value :: minValue
				elif(value > maxValue)
					do value :: maxValue
				end if
				ret obj.height <> value
			end func

			func apply(me_: @DocAr, obj: @Obj, data: lib@Int)
				var value: int :: data.value
				var minValue: int
				var maxValue: int
				do obj.getMinMax(&, &minValue, &, &maxValue)
				if(value < minValue)
					do value :: minValue
				elif(value > maxValue)
					do value :: maxValue
				end if
				do me_.move(obj =& me_.root ?(null, obj.name), obj.x, obj.y, obj.width, value, true)
			end func
		case %btnRbArPropOnPush
			var objs: []@Obj
			if(^me.holds = 0)
				do objs :: [me.root]
			else
				do objs :: me.holds.toArray()
			end if
			if(\obj_prop@show(objs))
				do me.changed :: true
				for i(0, ^objs - 1)
					do objs[i].reloadRes()
				end for
			end if
			do \form@updateUi()
			do \form@paintDrawEditor()
		end switch
	end func

	+*func loadImpl(xmlNode: xml@Node)
		var root: xml@Node :: xmlNode.findChild("root").firstChild()
		do me.root :: me.makeObj(root.getName())
		do me.root.load(root)
		var child: xml@Node :: xmlNode.findChild("children").firstChild()
		do me.nodes :: #list<@Obj>
		while(child <>& null)
			var node: @Obj :: me.makeObj(child.getName())
			do node.load(child)
			do me.nodes.add(node)
			do child :: child.next()
		end while
	end func

	+*func saveImpl(xmlNode: xml@Node)
		var root: xml@Node :: xmlNode.addChild("root")
		block
			var node: xml@Node :: root.addChild(me.root.kind())
			do me.root.save(node)
		end block
		var children: xml@Node :: xmlNode.addChild("children")
		do me.nodes.head()
		while(!me.nodes.term())
			var obj: @Obj :: me.nodes.get()
			var node: xml@Node :: children.addChild(obj.kind())
			do obj.save(node)
			do me.nodes.next()
		end while
	end func

	func makeObj(name: []char): @Obj
	end func

	func updateLt()
	end func

	enum Mode
		none
		put
		move
		resizeLT
		resizeRT
		resizeLB
		resizeRB
		resizeL
		resizeT
		resizeR
		resizeB
		sel
	end enum

	var src: [][]char
	+var root: @Obj
	var nodes: list<@Obj>
	var holds: list<@Obj>
	var clipboard: list<@Obj>
	var scrollOffsetX: int
	var scrollOffsetY: int
	var holdOriginX: int
	var holdOriginY: int
	var curOriginX: int
	var curOriginY: int
	var pageX: int
	var pageY: int
	var mode: Mode
	var updatingProp: bool

	func resizeObj(obj: @Obj, x: int, y: int, objX: &int, objY: &int, objWidth: &int, objHeight: &int)
		var x2: int :: x - me.holdOriginX
		var y2: int :: y - me.holdOriginY
		var modX: int
		var modY: int
		switch(me.mode)
		case %none, %sel
			do objX :: obj.x
			do objY :: obj.y
			do objWidth :: obj.width
			do objHeight :: obj.height
			ret
		case %put
			do objX :: round(&, obj.x)
			do objY :: round(&, obj.y)
			do objWidth :: round(&, obj.width)
			do objHeight :: round(&, obj.height)
		case %move
			do objX :: round(&, obj.x + x2)
			do objY :: round(&, obj.y + y2)
			do objWidth :: obj.width
			do objHeight :: obj.height
		case %resizeLT
			do objX :: round(&modX, obj.x + x2)
			do objY :: round(&modY, obj.y + y2)
			do objWidth :: obj.width - x2 + modX
			do objHeight :: obj.height - y2 + modY
		case %resizeRT
			do objX :: obj.x
			do objY :: round(&modY, obj.y + y2)
			do objWidth :: round(&, obj.width + x2)
			do objHeight :: obj.height - y2 + modY
		case %resizeLB
			do objX :: round(&modX, obj.x + x2)
			do objY :: obj.y
			do objWidth :: obj.width - x2 + modX
			do objHeight :: round(&, obj.height + y2)
		case %put, %resizeRB
			do objX :: obj.x
			do objY :: obj.y
			do objWidth :: round(&, obj.width + x2)
			do objHeight :: round(&, obj.height + y2)
		case %resizeL
			do objX :: round(&modX, obj.x + x2)
			do objY :: obj.y
			do objWidth :: obj.width - x2 + modX
			do objHeight :: obj.height
		case %resizeT
			do objX :: obj.x
			do objY :: round(&modY, obj.y + y2)
			do objWidth :: obj.width
			do objHeight :: obj.height - y2 + modY
		case %resizeR
			do objX :: obj.x
			do objY :: obj.y
			do objWidth :: round(&, obj.width + x2)
			do objHeight :: obj.height
		case %resizeB
			do objX :: obj.x
			do objY :: obj.y
			do objWidth :: obj.width
			do objHeight :: round(&, obj.height + y2)
		end switch

		var minWidth: int
		var minHeight: int
		var maxWidth: int
		var maxHeight: int
		do obj.getMinMax(&minWidth, &minHeight, &maxWidth, &maxHeight)
		if(objX < 0)
			do objX :: 0
		end if
		if(objY < 0)
			do objY :: 0
		end if
		if(objWidth < minWidth)
			do objWidth :: minWidth
		elif(objWidth > maxWidth)
			do objWidth :: maxWidth
		end if
		if(objHeight < minHeight)
			do objHeight :: minHeight
		elif(objHeight > maxHeight)
			do objHeight :: maxHeight
		end if

		func round(mod: &int, value: int): int
			if(\form@snap)
				do mod :: value % \form@snapValue
				ret value / \form@snapValue * \form@snapValue
			else
				do mod :: 0
				ret value
			end if
		end func
	end func

	func arrange(x: &int, y: &int)
		if(wnd@key(%shift))
			if((x - me.holdOriginX).abs() > (y - me.holdOriginY).abs())
				do y :: me.holdOriginY
			else
				do x :: me.holdOriginX
			end if
		end if
	end func

	class UndoAr(\doc@UndoCmd)
		+*func cmd()
			do me.doc.undoImpl(me)
		end func
	end class

	class UndoArPut(UndoAr)
		+var parent: []char
		+var kind: []char
		+var name: []char
		+var visible: bool
		+var x: int
		+var y: int
		+var width: int
		+var height: int
		+var props: dict<[]char, []char>
	end class

	class UndoArDel(UndoAr)
		+var name: []char
	end class

	class UndoArMove(UndoAr)
		+var name: []char
		+var x: int
		+var y: int
		+var width: int
		+var height: int
	end class

	class UndoArOrder(UndoAr)
		+var names: [][]char
	end class

	class UndoArRename(UndoAr)
		+var name: []char
		+var newName: []char
	end class

	class UndoArVisible(UndoAr)
		+var name: []char
		+var value: bool
	end class

	class UndoArProp(UndoAr)
		+var name: []char
		+var prop: []char
		+var value: []char
	end class

	func updateProp()
		do me.updatingProp :: true

		var name: []char
		var visible: bool
		var objXStr: []char
		var objYStr: []char
		var objWidthStr: []char
		var objHeightStr: []char
		if(^me.holds <= 1)
			var obj: @Obj
			if(^me.holds = 0)
				do obj :: me.root
			else
				do me.holds.head()
				do obj :: me.holds.get()
			end if
			do name :: obj.name
			do visible :: obj.visible
			var objX: int
			var objY: int
			var objWidth: int
			var objHeight: int
			do me.resizeObj(obj, me.curOriginX, me.curOriginY, &objX, &objY, &objWidth, &objHeight)
			do objXStr :: objX.toStr()
			do objYStr :: objY.toStr()
			do objWidthStr :: objWidth.toStr()
			do objHeightStr :: objHeight.toStr()
		else
			var obj: @Obj
			do name :: \common@langEn ?("(Multiple)", "(複数)")
			var sameVisible: bool :: true
			var sameX: bool :: true
			var sameY: bool :: true
			var sameWidth: bool :: true
			var sameHeight: bool :: true
			var objX: int
			var objY: int
			var objWidth: int
			var objHeight: int
			do me.holds.head()
			do obj :: me.holds.get()
			do visible :: obj.visible
			do me.resizeObj(obj, me.curOriginX, me.curOriginY, &objX, &objY, &objWidth, &objHeight)
			do me.holds.next()
			while(!me.holds.term())
				var objX2: int
				var objY2: int
				var objWidth2: int
				var objHeight2: int
				do obj :: me.holds.get()
				do me.resizeObj(obj, me.curOriginX, me.curOriginY, &objX2, &objY2, &objWidth2, &objHeight2)
				if(visible <> obj.visible)
					do sameVisible :: false
				end if
				if(objX <> objX2)
					do sameX :: false
				end if
				if(objY <> objY2)
					do sameY :: false
				end if
				if(objWidth <> objWidth2)
					do sameWidth :: false
				end if
				if(objHeight <> objHeight2)
					do sameHeight :: false
				end if
				do me.holds.next()
			end while
			do visible :: sameVisible ?(visible, false)
			do objXStr :: sameX ?(objX.toStr(), "*")
			do objYStr :: sameY ?(objY.toStr(), "*")
			do objWidthStr :: sameWidth ?(objWidth.toStr(), "*")
			do objHeightStr :: sameHeight ?(objHeight.toStr(), "*")
		end if
		do \form@groupRbAr.setVisible(true)
		do \form@groupRbAr.setRedraw(false)
		do \form@editRbArName.setText(name)
		do \form@chkRbArVisible.setChk(visible)
		do \form@editRbArX.setText(objXStr)
		do \form@editRbArY.setText(objYStr)
		do \form@editRbArWidth.setText(objWidthStr)
		do \form@editRbArHeight.setText(objHeightStr)
		do \form@groupRbAr.setRedraw(true)

		do me.updatingProp :: false
	end func

	func find(nodes: list<@Obj>, name: []char)
		do nodes.head()
		while(!nodes.term())
			if(nodes.get().name = name)
				ret
			end if
			do nodes.next()
		end while
	end func

	func put(parent: []char, kind: []char, name: []char, visible: bool, x: int, y: int, width: int, height: int, props: dict<[]char, []char>, recordUndo: bool): @Obj
		if(recordUndo)
			var undo: UndoArDel :: #UndoArDel
			do undo.doc :: me
			do undo.name :: name
			var redo: UndoArPut :: #UndoArPut
			do redo.doc :: me
			do redo.parent :: parent
			do redo.kind :: kind
			do redo.name :: name
			do redo.visible :: visible
			do redo.x :: x
			do redo.y :: y
			do redo.width :: width
			do redo.height :: height
			do redo.props :: props
			do me.undo.add(undo, redo)
		end if
		var obj: @Obj :: me.makeObj(kind)
		if(width = -1 & height = -1)
			do obj.getDefaultSize(&width, &height)
		end if
		do obj.init(name, visible, x, y, width, height, props)
		if(props <>& null)
			do obj.props :: props
			do obj.reloadRes()
		end if
		if(parent =& null)
			do me.nodes.add(obj)
		else
			do me.find(me.nodes, parent)
			do me.nodes.ins(obj)
		end if
		do me.changed :: true
		ret obj
	end func

	func del(name: []char, recordUndo: bool)
		do me.find(me.nodes, name)
		if(recordUndo)
			var obj: @Obj :: me.nodes.get()
			var parent: @Obj
			if(me.nodes.termOffset(1))
				do parent :: null
			else
				do parent :: me.nodes.getOffset(1)
			end if
			var undo: UndoArPut :: #UndoArPut
			do undo.doc :: me
			do undo.parent :: parent =& null ?(null, parent.name)
			do undo.kind :: obj.kind()
			do undo.name :: obj.name
			do undo.visible :: obj.visible
			do undo.x :: obj.x
			do undo.y :: obj.y
			do undo.width :: obj.width
			do undo.height :: obj.height
			do undo.props :: obj.props
			var redo: UndoArDel :: #UndoArDel
			do redo.doc :: me
			do redo.name :: obj.name
			do me.undo.add(undo, redo)
		end if
		do me.nodes.get().fin()
		do me.nodes.del()
		do me.changed :: true
	end func

	+func move(name: []char, x: int, y: int, width: int, height: int, recordUndo: bool)
		var obj: @Obj
		if(name =& null)
			do obj :: me.root
		else
			do me.find(me.nodes, name)
			do obj :: me.nodes.get()
		end if
		if(obj.x = x & obj.y = y & obj.width = width & obj.height = height)
			ret
		end if
		if(recordUndo)
			var undo: UndoArMove :: #UndoArMove
			do undo.doc :: me
			do undo.name :: name
			do undo.x :: obj.x
			do undo.y :: obj.y
			do undo.width :: obj.width
			do undo.height :: obj.height
			var redo: UndoArMove :: #UndoArMove
			do redo.doc :: me
			do redo.name :: name
			do redo.x :: x
			do redo.y :: y
			do redo.width :: width
			do redo.height :: height
			do me.undo.add(undo, redo)
		end if
		do obj.x :: x
		do obj.y :: y
		do obj.width :: width
		do obj.height :: height
		do me.changed :: true
	end func

	func order(names: [][]char, recordUndo: bool)
		if(recordUndo)
			var oldNames: [][]char :: #[^me.nodes][]char
			do me.nodes.head()
			var i: int :: 0
			while(!me.nodes.term())
				do oldNames[i] :: me.nodes.get().name
				do i :+ 1
				do me.nodes.next()
			end while
			var undo: UndoArOrder :: #UndoArOrder
			do undo.doc :: me
			do undo.names :: oldNames
			var redo: UndoArOrder :: #UndoArOrder
			do redo.doc :: me
			do redo.names :: names
			do me.undo.add(undo, redo)
		end if
		var newNodes: list<@Obj> :: #list<@Obj>
		for i(0, ^names - 1)
			do me.find(me.nodes, names[i])
			do newNodes.add(me.nodes.get())
		end for
		do me.nodes :: newNodes
		do me.changed :: true
	end func

	func rename(name: []char, newName: []char, recordUndo: bool)
		if(recordUndo)
			var undo: UndoArRename :: #UndoArRename
			do undo.doc :: me
			do undo.name :: newName
			do undo.newName :: name
			var redo: UndoArRename :: #UndoArRename
			do redo.doc :: me
			do redo.name :: name
			do redo.newName :: newName
			do me.undo.add(undo, redo)
		end if
		do me.find(me.nodes, name)
		do me.nodes.get().name :: newName
		do me.changed :: true
	end func

	+func visible(name: []char, value: bool, recordUndo: bool)
		var obj: @Obj
		if(name =& null)
			do obj :: me.root
		else
			do me.find(me.nodes, name)
			do obj :: me.nodes.get()
		end if
		if(recordUndo)
			var undo: UndoArVisible :: #UndoArVisible
			do undo.doc :: me
			do undo.name :: name
			do undo.value :: obj.visible
			var redo: UndoArVisible :: #UndoArVisible
			do redo.doc :: me
			do redo.name :: name
			do redo.value :: value
			do me.undo.add(undo, redo)
		end if
		do obj.visible :: value
		do me.changed :: true
	end func

	func prop(name: []char, prop: []char, value: []char, recordUndo: bool)
	end func

	func cloneObj(src: @Obj): @Obj
		var dst: @Obj :: me.makeObj(src.kind())
		do dst.name :: src.name
		do dst.visible :: src.visible
		do dst.x :: src.x
		do dst.y :: src.y
		do dst.width :: src.width
		do dst.height :: src.height
		do dst.props :: ##src.props
		ret dst
	end func

	func updateMultiple(chk: func<(@Obj, kuin@Class): bool>, apply: func<(@DocAr, @Obj, kuin@Class)>, data: kuin@Class)
		if(^me.holds <= 1)
			var obj: @Obj
			if(^me.holds = 0)
				do obj :: me.root
			else
				do me.holds.head()
				do obj :: me.holds.get()
			end if
			if(chk(obj, data))
				do me.undo.recordBegin()
				do apply(me, obj, data)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
		else
			var diff: bool :: false
			do me.holds.head()
			while loop(!me.holds.term())
				if(chk(me.holds.get(), data))
					do diff :: true
					break loop
				end if
				do me.holds.next()
			end while
			if(diff)
				do me.undo.recordBegin()
				do me.holds.head()
				while loop(!me.holds.term())
					var obj: @Obj :: me.holds.get()
					if(chk(obj, data))
						do apply(me, obj, data)
					end if
					do me.holds.next()
				end while
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
		end if
		do \form@updateUi()
	end func
end class

+enum PropType
	str
	int_
	float_
	bool_
	enum_
	color
	file
end enum

+class Obj()
	+*func cmp(t: kuin@Class): int
		ret t =& me ?(0, 1)
	end func

	+func load(node: xml@Node)
		var props: dict<[]char, []char> :: #dict<[]char, []char>
		var propsNames: [][]char :: me.propsNames()
		var propsTypes: []@PropType :: me.propsTypes()
		for i(0, ^propsNames - 1)
			var attr: []char :: node.getAttr(propsNames[i])
			if(attr =& null)
				switch(propsTypes[i])
				case %str
					do props.add(propsNames[i], "")
				end switch
			else
				do props.add(propsNames[i], attr)
			end if
		end for
		do me.init(node.getAttr("name"), node.getAttr("visible") = "true", node.getAttr("x").toInt(&), node.getAttr("y").toInt(&), node.getAttr("width").toInt(&), node.getAttr("height").toInt(&), props)
		do me.reloadRes()
	end func

	+func save(node: xml@Node)
		do node.setAttr("name", me.name)
		do node.setAttr("visible", me.visible ?("true", "false"))
		do node.setAttr("x", me.x.toStr())
		do node.setAttr("y", me.y.toStr())
		do node.setAttr("width", me.width.toStr())
		do node.setAttr("height", me.height.toStr())
		var propsNames: [][]char :: me.propsNames()
		for i(0, ^propsNames - 1)
			do node.setAttr(propsNames[i], me.props.get(propsNames[i], &))
		end for
	end func

	+func draw(x: float, y: float, width: float, height: float, zoom: float)
	end func

	+func getMinMax(minWidth: &int, minHeight: &int, maxWidth: &int, maxHeight: &int)
		do minWidth :: 10
		do minHeight :: 10
		do maxWidth :: lib@intMax
		do maxHeight :: lib@intMax
	end func

	+func getDefaultSize(width: &int, height: &int)
		do width :: 10
		do height :: 10
	end func

	+func kind(): []char
	end func

	+func icon(): int
		ret -1
	end func

	+func init(name: []char, visible: bool, x: int, y: int, width: int, height: int, props: dict<[]char, []char>)
		do me.name :: name
		do me.visible :: visible
		do me.x :: x
		do me.y :: y
		do me.width :: width
		do me.height :: height
		do me.props :: props =& null ?(#dict<[]char, []char>, props)
	end func

	+func fin()
	end func

	+func becomeParent(): bool
		ret false
	end func

	+func propsNames(): [][]char
	end func

	+func propsTypes(): []@PropType
	end func

	+func propsTypeDatas(): [][][]char
	end func

	+func reloadRes()
	end func

	+var name: []char
	+var visible: bool
	+var x: int
	+var y: int
	+var width: int
	+var height: int
	+var props: dict<[]char, []char>
end class

func getResizeArea(resizeAreaX: &int, resizeAreaY: &int, width: int, height: int)
	const resizeArea: int :: 8
	const padding: int :: 4
	do resizeAreaX :: resizeArea
	if(resizeAreaX > width / 2 - padding)
		do resizeAreaX :: width / 2 - padding
	end if
	do resizeAreaY :: resizeArea
	if(resizeAreaY > height / 2 - padding)
		do resizeAreaY :: height / 2 - padding
	end if
end func

func removePrefix(name: []char): []char
	if(name[0] <> '>')
		ret name
	end if
	var idx: int :: 1
	while(name[idx] = '>')
		do idx :+ 1
	end while
	ret name.sub(idx, -1)
end func

+func getParent(parentStack: stack<@Obj>, obj: @Obj): @Obj
	while(^parentStack > 0)
		var parent: @Obj :: parentStack.peek()
		if(parent.x <= obj.x & obj.x + obj.width <= parent.x + parent.width & parent.y <= obj.y & obj.y + obj.height <= parent.y + parent.height)
			ret parent
		end if
		do parentStack.get()
	end while
	ret null
end func

+func getPropAsInt(props: dict<[]char, []char>, name: []char): int
	var success: bool
	var value: []char :: props.get(name, &success)
	if(!success)
		ret 0
	end if
	var value2: int :: value.toInt(&success)
	if(!success)
		ret 0
	end if
	ret value2
end func

+func getPropAsFloat(props: dict<[]char, []char>, name: []char): float
	var success: bool
	var value: []char :: props.get(name, &success)
	if(!success)
		ret 0.0
	end if
	var value2: float :: value.toFloat(&success)
	if(!success)
		ret 0.0
	end if
	ret value2
end func

func getDefaultName(name: []char, nodes: list<@Obj>): []char
	var n: int :: 1
	while loop(true)
		var newName: []char :: name ~ n.toStr()
		var found: bool :: false
		do nodes.head()
		while loop2(!nodes.term())
			if(nodes.get().name = newName)
				do found :: true
				break loop2
			end if
			do nodes.next()
		end while
		if(!found)
			ret newName
		end if
		do n :+ 1
	end while
end func
